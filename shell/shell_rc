#!/usr/bin/env bash
# vim:filetype=bash

set -o pipefail

PKG_MANAGER=""

function log() {
    local _type="${1}"; shift
    local _color="" _t=""
    [[ -n $ZSH_VERSION ]] && local="local" || local="local -g"
    ${local} info_color="\033[38;2;85;255;126m" \
        warn_color="\033[38;2;255;170;10m" \
        error_color="\033[38;2;244;29;31m" \
        fatal_color="\033[5m\033[38;2;255;0;0m" \
        other_color="\033[38;2;251;255;208m" \
        nc="\033[0m"
    case "${_type}" in
        info) _color="${info_color}" _t="*" ;;
        warn) _color="${warn_color}" _t="^" ;;
        error) _color="${error_color}" _t="!" ;;
        fatal) _color="${fatal_color}" _t="#" ;;
        *) _color="${other_color}" _t="" ;;
    esac

    printf "[%b%s%b%s]: %b\n" "${_color}" "${_type}" "${nc}" "${_t}" "${*}"
}

function ColorPath() {
    local blue="\033[38;2;150;134;255m" nc="\033[0m"
    sed -e "s@${HOME}@${blue//\\/\\\\}~${nc//\\/\\\\}@g" <(printf "%s\n" "${1}")
}

function Bash_and_ZSH_setup() {
    local zsh_dir
    if [[ -n $BASH_VERSION ]]; then
        export HISTCONTROL="ignoredups:erasedups"
        set -o vi
    elif [[ -n $ZSH_VERSION ]]; then
        export ZSH="${HOME}/.oh-my-zsh"
        CASE_SENSITIVE=true
        ZSH_THEME=eastwood
        plugins+=(vi-mode git gitfast docker pass)
        source "${ZSH}/oh-my-zsh.sh"
        zsh_dir="$(find /usr/share/zsh* -type d -name 'zsh-syntax-highlighting')"
        source "${zsh_dir}"/*.zsh
        bindkey -s '^o' 'lfcd\n'
        autoload edit-command-line
        bindkey '^e' edit-command-line
        setopt HIST_IGNORE_DUPS
        setopt HIST_IGNORE_ALL_DUPS
        setopt HIST_SAVE_NO_DUPS
        setopt HIST_FIND_NO_DUPS
        setopt HIST_EXPIRE_DUPS_FIRST
        setopt NO_EXTENDED_HISTORY
        unsetopt EXTENDED_HISTORY
    fi
}

function Export_vars() {
    ### Global variables
    export HOSTNAME="$(cat /etc/hostname)"
    export LANG=en_US.UTF-8
    export WINEPREFIX="$HOME/wine"
    export HISTSIZE=1000000
    export HISTFILE="$HOME/.cache/histfile_$USER"
    export EDITOR="nvim"
    export BREW="/home/linuxbrew/.linuxbrew"
    export PATH="/usr/bin"
    export MEDIA="/run/media/$USER"
    export XDG_DATA_HOME="$HOME/.local/share"
    export HOME="${HOME:-"$(printf ~)"}"
    export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-"/run/user/$UID"}"
    export PAGER=less
    export LESS="-R -s"
    export LESSCHARSET=utf-8
}

function Alias_vars() {
    # Ls/Directory listing commands alias
    alias LS="eza --color=always --icons=always --octal-permissions --binary --across"
    alias LL="eza --long --color=always --icons=always --sort=created --group --long --header --classify=always --octal-permissions --binary --across --total-size"
    alias LA="eza --color=always --icons=always --group --octal-permissions --binary --across --almost-all"
    alias lll="eza --long --color=always --icons=always --group --numeric --long --header --classify=always --octal-permissions --binary --across --total-size"
    alias l="eza --long --color=always --icons=always --group --octal-permissions --binary --across --sort=created --reverse"
    alias ls="lsd --color=always --git --icon=always --group-dirs=first --classify 2> /dev/null"
    alias ll="lsd --long --color=always --git --icon=always --group-dirs=first --classify --permission octal --total-size 2> /dev/null"
    alias la="lsd --color=always --git --almost-all --icon=always --group-dirs=first --classify --permission octal --total-size 2> /dev/null"
    alias lsblk="lsblk --paths -o+SIZE --fs"

    # File operations alias
    alias mv="mv --verbose"

    # Navigation/cd aliases
    _CD_DIRS="mkdir -p \${dir} && cd \${dir}; unset dir"
    alias M="dir=\${HOME}/Music && ${_CD_DIRS}"
    alias P="dir=\${HOME}/Pictures && ${_CD_DIRS}"
    alias G="dir=\${HOME}/Grim_Screenshots && ${_CD_DIRS}"
    alias V="dir=\${HOME}/Videos && ${_CD_DIRS}"
    alias D="dir=\${HOME}/Downloads && ${_CD_DIRS}"
    alias L="dir=\${HOME}/LearnDir && ${_CD_DIRS}"
    alias d="dir=\${HOME}/dev && ${_CD_DIRS}"
    alias lfcd="cd \$(lf -last-dir-path=/dev/stdout)"
    alias media="/run/media/\${USER}"
    unset _CD_DIRS

    # Git aliases
    alias gs="git status"

    # Config file editing aliases
    _EDIT_STUFF="\${EDITOR:-vim} \"\${config}\"; unset config"
    alias zshrc="config=\$HOME/.zshrc && ${_EDIT_STUFF}"
    alias vimrc="config=\$HOME/.vimrc && ${_EDIT_STUFF}"
    alias nvimrc="config=\$HOME/.config/nvim/init.vim && ${_EDIT_STUFF}"
    alias swayconfig="config=\${HOME}/.config/sway/config && ${_EDIT_STUFF}"
    alias waybarconfig="config_dir=\${HOME}/.config/waybar && \${EDITOR:-vim} \"\${config_dir}\"; unset config_dir"
    unset _EDIT_STUFF

    # Package manager aliases
    alias useless_pkg="pacman -Qtdq"
    alias clean_cache="(paru -Scc || yay -Scc ) && sudo pacman -Scc"
    alias clear_cache="(paru -Scc || yay -Scc ) && sudo pacman -Scc"

    # System monitoring aliases
    alias nvtop="nvtop --delay 2"
    alias radeontop="radeontop --color"
    alias Dmesg="dmesg --color=always | less"
    alias watch="watch --no-title"
    alias systemmonitor="XDG_CURRENT_DESKTOP=KDE GTK_THEME=Adwaita:dark QT_QPA_PLATFORMTHEME=gtk plasma-systemmonitor"

    # Network/IP aliases
    alias ip="ip --color=auto"
    alias weather="curl wttr.in/24.5800,80.8369"

    # Application/tool aliases
    alias ncdu="ncdu --color dark"
    alias qemu="qemu-system-x86_64"
    alias sway="env XDG_SESSION_TYPE=wayland XDG_CURRENT_DESKTOP=sway WLR_RENDERER=vulkan sway &> /tmp/sway.log"
    alias VimBeGood="clear; podman run -it --rm brandoncc/vim-be-good:stable && printf '\n' && clear"
    alias gtypistH="gtypist --personal-best --max-error=1.8 --no-welcome-screen --term-cursor --word-processor --always-sure"
    alias qutebrowser="QT_QPA_PLATFORM=xcb QT_WEBENGINE_DISABLE_GPU=1 qutebrowser"
    alias colorchoser="env QT_QPA_PLATFORMTHEME=qt6ct kcolorchooser 2> /dev/null & disown"
    alias getcolors="env QT_QPA_PLATFORMTHEME=qt6ct kcolorchooser 2> /dev/null & disown"
    alias ffmpeg="ffmpeg -hide_banner"

    # Metadata/file info aliases
    alias exiftool="/usr/bin/vendor_perl/exiftool"
    alias metadata="/usr/bin/vendor_perl/exiftool"
    alias Fonts="fc-list : file | sed 's|.*/||' | sed 's/\.[^.]*$//' | sort -u"

    # System/log management aliases
    alias clear_systemd_journal_logs="sudo journalctl --rotate && sudo journalctl --vacuum-size=1K && sudo journalctl --vacuum-time=1s"
    alias sourceme="source ~/.zshrc"
    alias savehist="file=$HOME/.saved_shell_history && cat \$HISTFILE >> \${file} && unset file"

    # Flatpak application aliases
    _FP_RUN="flatpak run \"\${fp_name}\" || flatpak install \"\${fp_name}\" -y"
    alias fp-scrivano="fp_name=com.github.scrivanolabs.scrivano; ${_FP_RUN}; unset fp_name"
    alias fp-draw="fp_name=com.github.scrivanolabs.scrivano; ${_FP_RUN}; unset fp_name"
    alias fp-tipp10="fp_name=com.gitlab.tipp10.tipp10; ${_FP_RUN}; unset fp_name"
    alias fp-ktouch="fp_name=org.kde.ktouch; ${_FP_RUN}; unset fp_name"
    alias fp-typing="fp_name=org.kde.ktouch; ${_FP_RUN}; unset fp_name"
    alias fp-easyeffects="fp_name=com.github.wwmm.easyeffects; ${_FP_RUN}; unset fp_name"
    alias fp-effects="fp_name=com.github.wwmm.easyeffects; ${_FP_RUN}; unset fp_name"
    alias fp-zen="fp_name=app.zen_browser.zen; ${_FP_RUN}; unset fp_name"
    alias fp-pomodoro="fp_name=org.jousse.vincent.Pomodorolm; ${_FP_RUN}; unset fp_name"
    alias fp-pomodorolm="fp_name=org.jousse.vincent.Pomodorolm; ${_FP_RUN}; unset fp_name"
    alias fp-discord="fp_name=com.discordapp.Discord; ${_FP_RUN}; unset fp_name"
    alias fp-VideoEditor="fp_name=org.kde.kdenlive; ${_FP_RUN}; unset fp_name"
    alias fp-calculator="fp_name=io.github.Qalculate.qalculate-qt; ${_FP_RUN}; unset fp_name"
    alias fp-qcal="fp_name=io.github.Qalculate.qalculate-qt; ${_FP_RUN}; unset fp_name"
    unset _FP_RUN

    # Utility aliases
    alias NULL="/dev/null"
    alias clear="tput clear"
    alias reset="tput reset"
    alias start-kde="env \
        XDG_SESSION_TYPE=wayland \
        QT_QPA_PLATFORM=wayland \
        XDG_DESKTOP_PORTAL_BACKEND=wlr \
        GTK_THEME=Breeze:dark \
        QT_QPA_PLATFORMTHEME=gtk3 startplasma-wayland"
    alias start-sway="env \
        XDG_CURRENT_DESKTOP=sway \
        XDG_SESSION_DESKTOP=sway \
        XDG_SESSION_TYPE=wayland \
        QT_QPA_PLATFORM=wayland \
        GDK_BACKEND=wayland \
        XDG_DESKTOP_PORTAL_BACKEND=wlr \
        QT_QPA_PLATFORMTHEME=qt6ct \
        GTK_THEME=Breeze:dark \
        WLR_RENDERER=vulkan sway --unsupported-gpu"
}

### Determine package manager
function PackageManager() {
    local -a pkg_m_Arr=(pacman apt yum dnf yay xbps-install)

    for pkg_m in "${pkg_m_Arr[@]}"; do
        if command -v "${pkg_m}" &> /dev/null; then
            PKG_MANAGER="${pkg_m}"
            log info "System's package manager: '${pkg_m}'"
            return 0
        fi
    done
}; alias pkgm="PackageManager"; alias my_pkg_m="PackageManager"
alias my_package_manager="PackageManager"; alias my-package-manager="PackageManager"

### Just check basic utilities in system
function RequiredTools() {
    ## Get PackageManager
    [[ -z $1 ]] && log info "Most basic tools"
    PackageManager NULL
    local -a TOOL_ARR=()
    TOOL_ARR=(
        # Shells
        zsh bash dash
        # Editors
        nvim vim micro nano
        # Version control
        git
        # Networking
        curl rsync nmcli wget ssh traceroute dig
        # Compression
        gzip bzip2 xz zip
        # Container
        docker
        # filemanager
        yazi ranger
        # Build tools
        make cmake gcc clang
        # Scripting languages
        python ruby node npm
        # Productivity
        htop btop tmux figlet cowsay tree jq fzf bat lsd eza rg unzip zip
        # Compilers
        gcc clang gdb make cmake rustc
        # Media/ TUI visulas
        cava mpv imv feh pastel
        # Others
        jq lsd fzf bat eza rg yt-dlp rclone jq
        # DevOps & security extras (optional)
        kubectl ansible nmap john aircrack-ng
    )

    for binary in "${TOOL_ARR[@]}"; do
        if command -v "${binary}" &> /dev/null; then
            [[ -z $1 ]] && log info "Found '${BLUE}${binary}${NC}' in path: $(whereis ${binary} | cut -d' ' -f2)"
        else
            log error "'${BLUE}${binary}${NC}' Not Found. Install it using '$PKG_MANAGER'"
        fi
    done
    return 0
}; alias goodies="RequiredTools"; alias availabletools="RequiredTools"
alias mytools="RequiredTools"; alias tools="RequiredTools"

### Rotate text by 13
function rot13() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash

    local -a args=("$@")
    local -a rot13_=( "tr" "A-Za-z" "N-ZA-Mn-za-m" )
    local -a input=()
    local operation_type=""
    local arg=""
    local save_path=""
    local -i argc=${#args[@]}

    if [[ $# -lt 1 ]]; then
        log error "At least one arguments expected"
        log info "rot13 <file/string>"
        return 1
    fi

    for ((i=0;i<${#args[@]};i++)); do
        arg="${args[$i]}"
        if [[ "${arg}" == *=* ]]; then
            value="${arg##*=}"
            arg="${arg%%=*}"
        else
            value="${args[$((i+))]}"
            arg="${arg}"
        fi
        case "${arg}" in
            -s|-save|--save)
                save_path="${args[$(($i+1))]}"
                i=$((i+1))
                [[ -z "${save_path}" || ! -f "${save_path}" ]] && {
                    log error "Not a valid path: '${save_path}'"
                }
                ;;
            -s=*|-save=*|--save=*)
                save_path="${arg#*=}"
                [[ -z "${save_path}" || ! -f "${save_path}" ]] && {
                    log error "Not a valid path: '${save_path}'"
                }
                ;;
            *)
                [[ -n "${arg}" ]] && input+=("${arg}")
                ;;
        esac
    done

    [[ "${#input[@]}" -eq 0 ]] && {
        log error "input is empty"
        return 1
    }

    [[ -d "${input[@]}" ]] && {
        log error "Cannot use directories"
            return 1
    }

    if [[ -n "${save_path}" && -f  "${save_path}" ]]; then
        save_path="${save_path}"
        printf "%s: " "Create \"${save_path}\"? (y|n): "; printf '\n'
        read -r -n 1 YES
        [[ "${YES}" =~ ^(Y|y)$ ]] && touch "${save_path}"
    else
        unset save_path
    fi

    if [[ ! -f "${input[@]}" ]]; then
        [[ -n "${save_path}" ]] && "${rot13_[@]}" <<< "${input[@]}" > "${save_path}" || \
            "${rot13_[@]}" <<< "${input[@]}"
    else
        [[ -n "${save_path}" ]] && "${rot13_[@]}" < "${input[@]}" > "${save_path}" || \
            "${rot13_[@]}" < "${input[@]}"
    fi
}

### Fetch defined https_proxy and https_proxy variable to current shell environment
function Tor() {
    u_set="${1:-"NULL"}"

    set_var() {
        export HTTP_PROXY="socks5://127.0.0.1:9050"
        export HTTPS_PROXY="socks5://127.0.0.1:9050"
        export http_proxy="socks5://127.0.0.1:9050"
        export https_proxy="socks5://127.0.0.1:9050"
    }

    unset_var() {
        unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
    }

    case "${arg}" in
        un*) unset_var && return 0 ;;
        sto*) sudo pkill -f "sudo tor" && return 0;;
    esac

    if pgrep -f "sudo tor" &> /dev/null; then
        set_var
        return 0
    fi
    sudo pkill -f "sudo tor"
    sudo tor &> /dev/null & disown
    set_var
    unset -f set_var unset_var
}

### Extract a tar archive
function Extract() {
    local archive="$1"
    case ${archive} in
        *.tar)
            tar --extract --verbose --file="${archive}"
            ;;
        *.tar.gz)
            tar --extract --gzip --verbose --file="${archive}"
            ;;
        *.tar.xz)
            tar --extract --xz --verbose --file="${archive}"
            ;;
        *.tar.bzip2)
            tar --extract --bzip2 --verbose --file="${archive}"
            ;;
        *)
            log error "'${archive}' is not tar archieve"
            ;;
    esac
}

### Mount a remote to local mount point
function RcloneMount() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    RequiredTools 0
    local -a ARGS=("$@") matches=()
    local action="${ARGS[0]}" drive="${ARGS[1]}" mountPoint="${ARGS[2]}"
    local list=0 mount=0 umount=0 show_size=0
    local -a matches=()

    [[ $# -eq 0 ]] && {
        log error "At least one arguemnt expected"
            log info "$0 <show-size|list|mount|umount> drive"
            return 1
        }

    if [[ -n "$action" ]]; then
        case "$action" in
            l|-l|-list|--list|list) list=1 ;;
            s|-s|-show|--show|--show-size|a|about) show_size=1 ;;
            m|-m|-mount|--mount|mount) mount=1 ;;
            u|-u|-umount|--umount|umount) umount=1 ;;
            *) log error "Unknown action '${action}'"; return 1 ;;
        esac
    fi

    if [[ -n "$drive" ]]; then
        [[ -n "${drive#*=}" ]] && {
            drive="${drive#*=}"
        }

    [[ -n $BASH_VERSION ]] && mapfile -t matches < <(rclone listremotes | grep --color=never -i "${drive}")
    [[ -n $ZSH_VERSION ]] && {
        matches=("$(rclone listremotes | grep --color=never -i ${drive})")
    }

    if [[ ${#matches[@]} -eq 1 ]]; then
        drive=${matches[0]}
    elif [[ ${#matches[@]} -gt 1 ]]; then
        log error "Ambiguous drive name: multiple remotes: '${matches[*]}'"
        printf "Full Name of the remote: "
        read -r REMOTE
        drive="${REMOTE}"
    else
        log error "No remotes found"
        return 1
    fi

    [[ "${drive}" != *: ]] && drive+=:
    [[ -z "${drive}" ]] && {
        log error "No remotes. Exiting"
        return 1
    }
    log info "Remote: ${drive}"
        fi

        if [[ -n "${mountPoint}" ]]; then
            [[ -n "${mountPoint#*=}" ]] && {
                mountPoint="${mountPoint#*=}"
            }
        mkdir -p "${mountPoint}"
        [[ -d "${mountPoint}" ]] || log warn "Mount point '${mountPoint}' does not exist"
        fi

        [[ $list -eq 1 ]] && {
            rclone listremotes
        }

    if [[ -z "${drive}" && $listremotes -eq 0 ]]; then
        log error "Remote is empty"
        return 1
    fi

    [[ $mount -eq 1 && $umount -eq 1 ]] && {
        log warn "--mount and --umount cannot be together"
        return 1
    }

    [[ $show_size -eq 1 ]] && {
        rclone about ${drive}
    }

    if [[ $umount -eq 1 ]]; then
        [[ -z ${mountPoint} ]] && mountPoint=$(grep --color=never "${drive}" /proc/mounts | cut -d' ' -f2)
        if [[ -d "${mountPoint}" ]]; then
            fusermount -uz "${mountPoint}" || log error "Cannot remove '${DIR}'"
            rm -rf "${mountPoint}" && \
                log info "Cleaned '$(grep --color=always "${drive}" /proc/mounts | cut -d' ' -f2)'"
        fi
        return 0
    fi
    if [[ $mount -eq 1 ]]; then
        mountPoint="${mountPoint:="/tmp/defaultRemoteMount"}"
        [[ ! -d "${mountPoint}" ]] && mkdir -p "${mountPoint}"
        if rclone mount "${drive}":/ "${mountPoint}" --daemon; then
            grep "${mountPoint}" --color=always /proc/mounts
        fi
    fi
    return 0
}

### Suppliment function for compilation functions
function _compileExitHandler() {
    local exit_code="$1"
    shift
    local no_ext_filename="$1"
    shift
    local RM=0
    local -a total_files=()
    [[ $exit_code -gt 0 ]] && {
        log error "Compilation Failed"
            log error "Program exited with code : $exit_code"
            # Just return if compilation is failed
            return 1
        }
    for arg in "$@"; do
        if [[ "${arg}" == -* ]]; then
            [[ "${arg}" =~ ^(--rm|--remove|-rm|-r)$ ]] && RM=1
        else
            total_files+=("${arg}")
        fi
    done

    "${no_ext_filename}" "${total_files[@]}" # Run the compiled binary

    if [[ $RM -eq 1 ]]; then
        if rm -f "${no_ext_filename}"; then
            log info "Cleaned: ${no_ext_filename}"
        else
            log error "Failed to remove: ${no_ext_filename}"
        fi
    fi
}

### GUI develeopment (Debuging enabled)
function GUI_BUILD_DEBUG() {
    local FILE="$(realpath $1)"
    local NO_EXT_FILENAME="${FILE%.*}"
    shift
    [[ -f "$FILE" ]] && gcc -std=c++20 -Wall -Wextra -Werror -Wconversion \
        -Wshadow -pedantic -O0 -fno-inline -lstdc++ -lglfw -lGL -lglad -lm \
        "${FILE}" -o "${NO_EXT_FILENAME}" && "${NO_EXT_FILENAME}"
    "${NO_EXT_FILENAME}"
    _compileExitHandler $? "${NO_EXT_FILENAME}" "$@"
}

### GUI develeopment (release mode)
function GUI_BUILD_RELEASE() {
    local FILE="$(realpath $1)"
    local NO_EXT_FILENAME="${FILE%.*}"
    shift
    [[ -f "$FILE" ]] && gcc -std=c++20 -Wall -Wextra -Wconversion -Wshadow \
        -pedantic -O3 -flto -march=native -funroll-loops -fomit-frame-pointer \
        -lstdc++ -lglfw -lGL -lglad -lm \
        "${FILE}" -o "${NO_EXT_FILENAME}" && "${NO_EXT_FILENAME}"
    "${NO_EXT_FILENAME}"
    _compileExitHandler $? "${NO_EXT_FILENAME}" "$@"
}

# Predefined compiler flags for C/C++ source units
function Compile() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    local -a args=("$@")
    local -a files=()
    local -a cmd_flags=() c_sources=() cpp_sources=()
    local arg="" out_="" output="main__" CC_="gcc"
    local output_type="captured"
    local -i remove_output=0 debug=0

    arg=""; for ((i=0; i < ${#args[@]}; i++ )); do
        arg="${args[$i]}"
        if [[ "${arg}" == -* ]]; then
            case "${arg}" in
                -rm|--rm|--remove)
                    remove_output=1
                    ;;
                -o|--output)
                    output="${arg}"
                    ;;
                -o=*|--output=*)
                    output="${arg#*=}"
                    [[ -z "${output}" ]] && output="main___"
                    ;;
                -*clang)
                    CC_="clang"
                    ;;
                -*clang=*)
                    CC_="${arg#*=}"
                    [[ -z "${CC_}" ]] && CC_="gcc"
                    ;;
                -*def*)
                    output_type="default"
                    ;;
                *)
                    log error "Invalid flag: '${arg}'"
                    ;;
            esac
        else
            [[ -s "${arg}" && -f "${arg}" ]] && files+=( "${arg}" ) || log error "Not a file: '${arg}'"
        fi
    done

    arg=""; for ((i=0; i < ${#files[@]}; i++ )); do
        arg="${args[$i]}"
        case "${arg}" in
            *.[cC]++|*.[cC][pP][pP])
                cpp_sources+=( "${arg}" )
            ;;
            *.[cC])
                c_sources+=( "${arg}" )
            ;;
            *)
                log error "Not a valid sources file: '${arg}'"
            ;;
        esac
    done

    if [[ ${#cpp_sources[@]} > 0 ]]; then
        cmd_flags=( "-x" "c++" "-std=c++20" )
        cmd_flags+=( "-lstdc++" "-lm" )
        cmd_flags+=( "-pedantic" "-Wall" "-Wextra" "-Werror" "-fno-elide-constructors" )
        [[ $debug -eq 1 ]] && cmd_flags+=( "-DDEBUG" )

        log info "$CC_ ${cmd_flags[*]} ${cpp_sources[*]} -o ${output}"
        $CC_ "${cmd_flags[@]}" "${cpp_sources[@]}" -o "${output}"
        if [[ $? -ne 0 ]]; then
            log error "Compilation failed"
            return 1
        fi
        log info "Running: ${output}: "

        if [[ "${output_type}" != "captured" ]]; then
            ./"${output}"
            return $?
        fi

        local lines out_
        if ! out_="$(./"${output}")"; then
            log error "Execution failed"
        fi

        if [[ -n "${ZSH_VERSION}" ]]; then
            lines=("${(f)out_}")
        else
            mapfile -t lines <<< "${out_}"
        fi

        for line in "${lines[@]}"; do
            printf "    %b\n" "${line}"
        done

        if [[ $remove_output -eq 1 ]]; then
            rm -f "${output}" && log info "cleaned: '${output}'"
        fi
        printf "\n"
    fi

    if [[ ${#c_sources[@]} > 0 ]]; then
        cmd_flags=( "-x" "c" "-std=c99" )
        cmd_flags+=( "-lstdc++" "-lm" )
        cmd_flags+=( "-pedantic" "-Wall" "-Wextra" "-Werror" )
        [[ $debug -eq 1 ]] && cmd_flags+=( "-DDEBUG" )

        log info "$CC_ ${cmd_flags[*]} ${c_sources[*]} -o ${output}"
        $CC_ "${cmd_flags[@]}" "${c_sources[@]}" -o "${output}"
        if [[ $? -ne 0 ]]; then
            log error "Compilation failed"
            return 1
        fi
        log info "Running: ${output}: "

        if [[ "${output_type}" != "captured" ]]; then
            ./"${output}"
            return $?
        fi

        local lines out_
        if ! out_="$(./"${output}")"; then
            log error "Execution failed"
        fi

        if [[ -n "${ZSH_VERSION}" ]]; then
            lines=("${(f)out_}")
        else
            mapfile -t lines <<< "${out_}"
        fi

        for line in "${lines[@]}"; do
            printf "    %b\n" "${line}"
        done

        if [[ $remove_output -eq 1 ]]; then
            rm -f "${output}" && log info "cleaned: '${output}'"
        fi
        printf "\n"
    fi

}

### Set the path with default locations
function SetPath() {
    PATH+=: PATH+="/usr/sbin:/bin:/sbin:/usr/local/bin:/usr/local/sbin"
    PATH+=: PATH+="$(find ~/.bin/* -type d | paste -sd:)"
    PATH+=: PATH+="${HOME}/.local/bin:${HOME}/.cargo/bin:${HOME}/.npm_global/bin:${BREW}/bin"
    PATH+=: PATH+="${HOME}/.scripts"

    local tmp_path="/tmp/.home.path"
    if [[ ! -s "${tmp_path}" ]] ;then
        printf '%s\n' "$PATH" &> "${tmp_path}"
    else
        export PATH="$(cat "${tmp_path}")"
    fi
}

### Show all the paths in $PATH
function ShowPath() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    local IFS=$':' i=0
    for path in $PATH; do
        sed "s@${HOME}@~@g" <(printf '%-2s %-2s %s\n' "${i}" '->' "${path}")
        ((i++))
    done
}; alias show_paths="ShowPath"

### Set refresh rate
function set_refresh_rate_to() {
    local -i req_hz=$1
    local output="" mode=""
    local px="" hz=""
    local local_grep="$(cut -d' ' -f2 <(whereis grep))"

    if [[ "${XDG_SESSION_TYPE}" == wayland ]]; then
        output="$(wlr-randr | head -n1 | cut -d' ' -f1)"
        px=$(wlr-randr | ${local_grep} current | awk -F' ' '{ print $1 }')
        hz=$(wlr-randr | ${local_grep} -P "(?=.*${px})(?=.*${req_hz})" | ${local_grep} -o -E "${req_hz}\.[0-9]+")
        mode="${px}px@${hz}Hz"
        wlr-randr --output ${output} --mode ${mode} && exit 0 || log error "Cannot set $req_hz"
    elif [[ "${XDG_SESSION_TYPE}" == x11 ]]; then
        output=$(xrandr | ${local_grep} 'connected primary' | cut -d' ' -f1)
        px=$(xrandr | ${local_grep} '\*' | awk -F' ' '{ print $1 }')
        hz=$(xrandr | ${local_grep} "${px}" | ${local_grep} -Eo "${req_hz}\.[0-9]+")
        log info "xrandr --output ${output} --mode ${px} --rate ${hz}"
        xrandr --output "${output}" --mode "${px}" --rate "${hz}" || log error "Cannot set $req_hz"
    fi
}

### Set refresh rate to 144Hz
function 144hz() {
    set_refresh_rate_to 144
}

### Set refresh rate to 60Hz
function 60hz() {
    set_refresh_rate_to 60
}

### AI in terminal
function gpt() {
    local type_="$1"
    [[ $# -gt 0 ]] && shift
    local -a prompt_=("$@")
    local session_log="/tmp/.tgpt_TYPE_$(date +%F_%T).log"
    case "${type_}" in
        dev)
            AI_PROVIDER=phind tgpt --multiline --log "${session_log/TYPE/phind}"
            ;;
        img)
            local img_path="${HOME}/Pictures/tgpt/"
            mkdir -p "${img_path}"
            img_path+="tgpt_$(date +%F_%T).png"
            tgpt --img --out "${img_path}" --width 512 --height 512 "${prompt_[*]}" && \
                log info "Your imge: $(ColorPath "${img_path}")"
            ;;
        *)
            AI_PROVIDER=isou tgpt --multiline --log "${session_log/TYPE/pollinations}"
            ;;
    esac
}; alias devgpt='gpt dev'; alias gptimg='gpt img'

### Pretty `cat` like command with colors
function CatBat() {
    local -a args=("$@")
    local -a batargs=()
    for arg in "${args[@]}"; do
        case "${arg}" in
            *.conf)
                batargs+=("--language=ini" "${arg}")
                ;;
            *)
                batargs+=("${arg}")
                ;;
        esac
    done
    /usr/bin/bat --theme-dark=TwoDark --color=always --decorations=never --paging=never "${batargs[@]}"
}

### Pretty `less` like command with colors
function Less() {
    local -a args=("$@")
    local -a batargs=()
    for arg in "${args[@]}"; do
        case "${arg}" in
            *.conf)
                batargs+=("--language=ini" "${arg}")
                ;;
            *)
                batargs+=("${arg}")
                ;;
        esac
    done
    /usr/bin/bat --theme-dark=TwoDark --color=always --decorations=never --paging=always "${batargs[@]}"
}

### Temporay writing
function t() {
    local temp_file="$(mktemp -t temp_edit_.XXXX)"
    local session_type=""
    "${EDITOR}" "${temp_file}"
    if [[ "${XDG_SESSION_TYPE}" == wayland ]]; then
        wl-copy < "${temp_file}" && log info "Wayland copy"
    elif [[ "${XDG_SESSION_TYPE}" == x11 ]]; then
        xsel < "${temp_file}" && log info "x11 copy"
    fi
    rm "${temp_file}"
}

### Spanish lessons
function Spanish() {
    local file="${HOME}/LearnDir/Language/Spanish/Lesson_$(( $(date +%s)/86400 - 20152))_$(date +%d-%b-%Y_).md"

    mkdir -p "$(dirname "${file}")"

    if [[ ! -f "${file}" ]]; then
        touch "${file}"
        log info "Created $(ColorPath "${file}")"
    fi

    if [[ -n "${EDITOR}" ]]; then
        command -v "$EDITOR" > /dev/null 2>&1 || EDITOR="vim"
        "${EDITOR:-"vim"}" "${file}"
        return 0
    else
        log error "Your EDITOR variable is unset. Please update it."
    fi

}

# Set existing locale
function SetLocale() {
    local locale="${1:-"en_US.UTF-8"}"
    export LC_ALL="${locale}"
    export LC_CTYPE="${locale}"
    export LC_NUMERIC="${locale}"
    export LC_TIME="${locale}"
    export LC_COLLATE="${locale}"
    export LC_MONETARY="${locale}"
    export LC_MESSAGES="${locale}"
    export LC_PAPER="${locale}"
    export LC_NAME="${locale}"
    export LC_ADDRESS="${locale}"
    export LC_TELEPHONE="${locale}"
    export LC_MEASUREMENT="${locale}"
    export LC_IDENTIFICATION="${locale}"
    export LANG="${locale}"
}

# Generate locale
function LocaleGen() {
    local locale_name="${1}"
    IFS='.' lang enc <<< "${locale_name}"
    sudo localedef -i "${lang}" -f "${enc}"
    SetLocale "${locale_name}"
}

### Grammer checker
function grammer_check() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    local arg="$1"
    local raw_text

    if [[ -f "${arg}" ]]; then
        raw_text=$(<"${file}")
    else
        raw_text="${*}"
    fi
    # Read and sanitize input

    # Remove control characters (except \n and \t)
    local clean_text
    clean_text=$(printf '%s' "$raw_text" | tr -d '\000-\011\013\014\016-\037')

    # Send to LanguageTool
    local json
    json=$(curl -s -X POST "https://api.languagetool.org/v2/check" \
        --data-urlencode "language=en-US" \
        --data-urlencode "text=$clean_text")

        # Check for valid JSON
        if ! echo "$json" | jq . >/dev/null 2>&1; then
            echo "jq failed to parse the response. Possibly invalid input or corrupted JSON."
            return 1
        fi

        local red=$(tput setaf 1)
        local green=$(tput setaf 2)
        local yellow=$(tput setaf 3)
        local reset=$(tput sgr0)

        echo "$json" | jq -r --arg red "$red" --arg green "$green" --arg yellow "$yellow" --arg reset "$reset" '
        if (.matches | length) == 0 then
            "\($green)No issues found \($reset)"
        else
            .matches[] |
                "\($red)Error:\($reset) \(.message)\n" +
            "\($yellow)Context:\($reset) \"\(.context.text)\"\n" +
            "\($green)Suggestion(s):\($reset) " +
            (if (.replacements | length) > 0 then
            (.replacements | map(.value) | join(", "))
        else
            "None"
        end) + "\n" +
        "Offset: \(.offset)\n---"
    end
    '
}

# sysstat: lightweight stats (net + disk)
function sysstat() {
    local iface="${1:-$(ip route | grep default | awk '{print $5}')}"
    local dev="${2:-nvme0n1}"
    local interval="${3:-1}"
    local iterations="${4:-1}"

    local rx_path="/sys/class/net/$iface/statistics/rx_bytes"
    local tx_path="/sys/class/net/$iface/statistics/tx_bytes"
    local stat_path="/sys/block/$dev/stat"
    local st_dir="/sys/block/$dev/statistics"

    [[ ! -e $rx_path ]] && { log error "No such iface: $iface"; return 1; }
    [[ ! -e $stat_path ]] && { log error "No such block dev: $dev"; return 1; }

    human() {
        local bytes=$1
        if (( bytes > 1073741824 )); then
            awk -v b=$bytes 'BEGIN{printf "%.2f GiB", b/1073741824}'
        elif (( bytes > 1048576 )); then
            awk -v b=$bytes 'BEGIN{printf "%.2f MiB", b/1048576}'
        elif (( bytes > 1024 )); then
            awk -v b=$bytes 'BEGIN{printf "%.2f KiB", b/1024}'
        else
            printf "%d B" "$bytes"
        fi
    }

    get_disk_bytes() {
        if [[ -r "$st_dir/read_bytes" && -r "$st_dir/write_bytes" ]]; then
            # some block devices export these
            local rd=$(<"$st_dir/read_bytes")
            local wr=$(<"$st_dir/write_bytes")
            echo "$rd $wr"
        else
            # fallback to parsing /stat
            # field3=sectors_read, field7=sectors_written
            awk '{print $3*512, $7*512}' "$stat_path"
        fi
    }

    # one-shot totals
    if (( iterations == 1 )); then
        local rx=$(<"$rx_path") tx=$(<"$tx_path")
        read -r rd wr < <(get_disk_bytes)

        printf '%s\n' ""
        printf '%s:\n' "Network"
        printf '    %-4s: %s\n' "Total Download" "$(human $rx)"
        printf '    %-4s: %s\n' "Total Upload"   "$(human $tx)"
        printf '    %-4s: %s\n' "Total Net"      "$(human $((rx+tx)))"
        printf '%s\n' ""
        printf '%s:\n' "Disk I/O"
        printf '    %-4s: %s\n' "Disk Read"      "$(human $rd)"
        printf '    %-4s: %s\n' "Disk Write"     "$(human $wr)"
        printf '%s\n' ""
        return 0
    fi

    # realtime mode
    local prev_rx=$(<"$rx_path") prev_tx=$(<"$tx_path")
    read -r prev_rd prev_wr < <(get_disk_bytes)

    printf "\n"
    while :; do
        sleep "$interval"
        local rx=$(<"$rx_path") tx=$(<"$tx_path")
        read -r rd wr < <(get_disk_bytes)

        local drx=$((rx - prev_rx))
        local dtx=$((tx - prev_tx))
        local drd=$((rd - prev_rd))
        local dwr=$((wr - prev_wr))

        printf "\033[1A\033[2K"
        printf "%s | Net ↓ %s/s ↑ %s/s | Disk R %s/s W %s/s\n" \
            "$(date +%T)" \
            "$(human $drx)" \
            "$(human $dtx)" \
            "$(human $drd)" \
            "$(human $dwr)"

        prev_rx=$rx prev_tx=$tx prev_rd=$rd prev_wr=$wr
        (( iterations > 0 )) && (( --iterations == 0 )) && break
    done
    unset -f get_disk_bytes human
}

### Set CPU frequencies to certain limits
function SetPower() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    local profile="$1"
    local -i stapm fast slow apuslow
    local -i t=1000
    local -i core_temp=0
    local -i stapm fast slow apuslow core_temp

    command -v ryzenadj &> /dev/null || {
        log error "'ryzenadj' not found, install it"
        return 1
    }

    case "${profile}" in
        verylow*|very-low*)
            stapm=$((5*t)) fast=$((5*t)) slow=$((5*t)) apuslow=$((5*t)) core_temp=60
            ;;
        low*)
            stapm=$((10*t)) fast=$((10*t)) slow=$((8*t)) apuslow=$((8*t)) core_temp=65
            ;;
        vibe*|coding*)
            stapm=$((15*t)) fast=$((15*t)) slow=$((12*t)) apuslow=$((12*t)) core_temp=70
            ;;
        balanced*)
            stapm=$((25*t)) fast=$((25*t)) slow=$((20*t)) apuslow=$((20*t)) core_temp=75
            ;;
        high*)
            stapm=$((45*t)) fast=$((45*t)) slow=$((35*t)) apuslow=$((35*t)) core_temp=80
            ;;
        boost*)
            stapm=$((65*t)) fast=$((65*t)) slow=$((54*t)) apuslow=$((54*t)) core_temp=85
            ;;
        stock|default)
            log info "Your default stock values"
            stapm=$((65*t)) fast=$((65*t)) slow=$((54*t)) apuslow=$((54*t)) core_temp=90
            sudo ryzenadj \
                --stapm-limit=$stapm \
                --fast-limit=$fast \
                --slow-limit=$slow \
                --apu-slow-limit=$apuslow \
                --stapm-time=$((1*t)) \
                --slow-time=$((5*t)) \
                --vrm-current=$((58*t)) \
                --vrmsoc-current=$((15*t)) \
                --vrmmax-current=$((110*t)) \
                --vrmsocmax-current=$((20*t)) \
                --tctl-temp=$core_temp \
                --apu-skin-temp=$((42*t)) \
                --dgpu-skin-temp=$((51*t)) 2> /dev/null
            return 0
            ;;

        info)
            sudo ryzenadj --info 2> /dev/null
            return 0
            ;;
        *)
            log info "Usage: ${FUNCNAME[0]:-"${funcstack[1]}"} [verylow|low|balanced|high|boost|stock]"
            return 1
            ;;
    esac
    sudo ryzenadj --stapm-limit=$stapm --fast-limit=$fast --slow-limit=$slow --apu-slow-limit=$apuslow --tctl-temp=$core_temp 2> /dev/null
}

function waterfox_dev() {
    local firefox_profile_name="$1"
    local firefox_profile_dir="${HOME}/.profiles"
    local profile="" browser=""

    if command -v waterfox &> /dev/null; then
        browser="waterfox"
    elif command -v firefox &> /dev/null; then
        log info "Waterfox not found, using firefox"
        browser="firefox"
    else
        log error "Waterfox not installed"
        return 1
    fi

    mkdir -p "${firefox_profile_dir}"

    if [[ "${firefox_profile_name}" != */* ]]; then
        profile="${firefox_profile_dir}/${firefox_profile_name:-"dev"}"
    else
        profile="${firefox_profile_name}"
    fi

    log info "$browser --profile $(ColorPath "${profile}") &> /dev/null & disown"

    $browser --profile "${profile}" &> /dev/null & disown

    if [[ "${XDG_CURRENT_DESKTOP}" == "sway" ]]; then
        timeout --signal SIGKILL 6s bash -c "
            while ! swaymsg -t get_tree -r | jq -e '.. | select(type == \"object\" and (.app_id? | type == \"string\" and test(\"^${browser}\")))' &> /dev/null; do
                sleep 0.01
            done
            sleep 0.2
            swaymsg '[app_id=\"${browser}\"] resize set width 1444 height 784'
        "
    fi
}

# A Human-readable value of a process's memory usage
function psmem() {
    local process_name="${1}"
    local -a cmd_args=()

    if [[ -n "${process_name}" ]]; then
        cmd_args+=("-p" "$(pgrep -d, "${process_name}")")
    else
        cmd_args+=("-e")
    fi
    awk '{
        rss=$3/1024;
        if (rss>=1024) {
            gb=sprintf("%.2f GB", (rss/1024));
            printf "%-20s %s\n", gb, substr($0, index($0,$2));
        }
        else {
            mb=sprintf("%.2f MB", rss);
            printf "%-20s %s\n", mb, substr($0, index($0,$2));
        }

    }' <<< "$(ps --sort="-%mem" "${cmd_args[@]}" -o'user,group,rss,%mem,%cpu,command')" | grep -v "0.00 MB" | less -c -
}

function pscpu() {
    local process_name="${1}"
    local -a cmd_args=()
    if [[ -n "${process_name}" ]]; then
        cmd_args+=("-p" "$(pgrep -d, "${process_name}")")
    else
        cmd_args+=("-e")
    fi
    ps --sort="-%cpu" "${cmd_args[@]}" -o'user,group,%mem,%cpu,command' | less -c -
}

function available_mem() {
    Mib=$(awk '
        /MemFree:/            { free      += $4 }
        /Active\(file\): /    { act_file  += $4 }
        /Inactive\(file\): /  { inact_file+= $4 }
        /SReclaimable:/       { reclaim   += $4 }
        /Shmem:/              { shmem     += $4 }
        END {
            total = free + act_file + inact_file + reclaim
            deduction = shmem
            reclaimable_file = act_file + inact_file + reclaim
            if (deduction > 0.5 * reclaimable_file)
                deduction = 0.5 * reclaimable_file
                available_kib = total - deduction
                printf "%.0f", available_kib / 1024
            }
    ' /sys/devices/system/node/node*/meminfo)

    printf "Available RAM: %s MiB\n" "${Mib}"

}

function brightness() {
    local -i desired_brightness=$1
    local -i max_brightness=$(cat /sys/class/backlight/*/max_brightness)
    local -i new_brightness=$(awk '{ printf "%.0f", $1 * ($2/100) }' <<< "$max_brightness $desired_brightness" )
    local brightness_file="$(printf /sys/class/backlight/*/brightness)"
    log info "Command: echo ${new_brightness} > ${brightness_file}"
    if ! echo ${new_brightness} > ${brightness_file} 2> /dev/null; then
        log warn "Previous command failed, running with sudo"
        log info "Command: sudo bash -c \"echo ${new_brightness} > ${brightness_file}\""
        sudo bash -c "echo ${new_brightness} > ${brightness_file}" 2> /dev/null
    fi
}

### Download any video
function Yt-dlp_download() {
    local url="$@"
    yt-dlp -f "bestvideo[height<=1080][ext=webm]/bestvideo[height<=1080]+bestaudio" "${url[@]}"
}

function GDB() {
    local -a args=("${@}")
    /usr/bin/env gdb -ex 'break main' -ex 'run' -ex 'lay split' "${args[@]}"
}

### Get Ip and location info for current Network
function Ip() {
    command -v curl &> /dev/null || {
        log error "'curl' not installed"
            return 1
        }
    if command -v bat &> /dev/null; then
        bat --decorations=never --color=always --paging=never --language json <<< $(curl -s -4 ipinfo.io)
    else
        log warn "'bat' not installed"
        curl -4 ipinfo.io
    fi
}

### Update grub
function update-grub() {
    local grub_config="/boot/grub/grub.cfg"
    sudo -v
    run_cmd() {
        local -a cmd=("${@}")
        log info "${cmd[*]}"
        "${cmd[@]}" # Run the command list
    }
    if [[ -f "${grub_config}.bak" ]]; then
        run_cmd sudo cp "${grub_config}" "${grub_config}_$(date +%d-%b-%Y-%T_%p).bak"
    else
        run_cmd sudo cp "${grub_config}" "${grub_config}.bak"
    fi
    run_cmd sudo grub-mkconfig -o "${grub_config}"
}

### Sort by file size
function Sort() {
    local -a total_args=("$@")
    if [[ ${#total_args} -eq 0 ]];then
        log error "Please profile items"
        return 1
    fi
    du -sh "${total_args[@]}" | /usr/bin/sort --numeric-sort
}

# Random MAC address
function gen_mac() {
    if command -v od &> /dev/null; then # od from coreutils
        [[ -n $BASH_VERSION ]] && flag="-a"
        [[ -n $ZSH_VERSION ]] && flag="-A"
        IFS=' ' read -r ${flag} mac < <(od -An -tx1 -N6 /dev/urandom)
        printf '%s:%s:%s:%s:%s:%s\n' "${mac[@]}"
    elif command -v hexdump &> /dev/null; then # hexdump from util-linux or busy-box
        for i in {1..6}; do
            printf '%02x' "$(hexdump -ve '/1 "%02x"' -n1 /dev/urandom)"
            [[ $i -lt 6 ]] && printf : || printf '\n'
        done
    elif command -v openssl &> /dev/null; then # openssl from openssl
        for i in {1..6}; do
            printf '%.2s' "$(head -c1 /dev/urandom | openssl dgst -sha1 - | cut -d' ' -f2)"
            { [[ $i -lt 6 ]] && printf :; } || printf '\n'
        done
    fi
}

# Print specific line from a file
function print_line() {
    local line="${1:-1}"
    local file="${2:-""}"

    if [[ -z "${line}" || $# -eq 0 ]]; then
        log usage "${FUNCNAME[0]:-"${funcstack[1]}"} [LINE] [FILE]"
        return 1
    fi
    awk "NR==${line}" "${file}"
}

function mpv_vulkan() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    local -a args=("${@}")
    local -a file_items=()
    local -a dir_items=() all_dir_items=()
    local -a dirs_=()
    local -a files=()
    local -a cmd_flags=()
    local -a cmd_args=()

    # Separate files, directories, other options
    for arg in "${args[@]}"; do
        if [[ -f "${arg}" ]]; then
            files+=("${arg}")
        elif [[ -d "${arg}" ]]; then
            dirs_+=("${arg}")
        else
            cmd_args+="${arg}"
        fi
    done

    # if there are files use them directly
    if [[ "${#files[@]}" -gt 0 ]]; then
        file_items=("${files[@]}")
    fi

    # if there are directories select files interactively
    if [[ "${#dirs_[@]}" -gt 0 ]]; then
        for ((i=0; i<${#dirs_[@]};i++)); do
            dir="${dirs_[$i]}"
            cd "${dir}"
            if [[ -n $BASH_VERSION ]]; then
                mapfile -t dir_items < <(fzf --multi)
            elif [[ -n $ZSH_VERSION ]]; then
                dir_items=("${(@f)"$(fzf --multi)"}")
            fi
            dir_items=("${dir_items[@]/#/${dir}/}")
            all_dir_items+=("${dir_items[@]}")
            cd - &> /dev/null
        done
    fi

    # Prepare command line flags for mpv
    local -a cmd_flags=(
        "--vid=auto"
        "--audio=auto"
        "--audio-device=pulse"
        "--volume=94"
        "--osc=no"
        "--fullscreen"
        "--scale=ewa_lanczos4sharpest"
        "--script-opts=mpris=yes"
        "--vo=gpu-next"
        "--hwdec=vulkan"
        "--gpu-api=vulkan"
        "--hdr-compute-peak"
        "--loop-playlist=inf"
        "--msg-level=ffmpeg/demuxer=error"
        "--really-quiet"
    )
    # Execute the command with necessary flags and files
    /usr/bin/mpv "${cmd_flags[@]}" "${cmd_args[@]}" "${file_items[@]}" "${all_dir_items[@]}" 2> /dev/null
}

function ToggleDrivers() {
    local -a args=("$@")

    toggle_driver_() {
        local module="${1}"
        local device="${2}"
        [[ $# -ne 2 ]] && return 1
        if lsmod | /usr/bin/grep "^${module}" &> /dev/null; then
            sudo rmmod -f "${module}" && log info "Disabled ${device}"
        else
            sudo modprobe "${module}" && log info "Enabled ${device}"
        fi
    }

    for arg in "${args[@]}"; do
        case ${arg} in
            [Cc][Aa][Mm]*) # camera
                toggle_driver_ "uvcvideo" "Camera"
            ;;
            [Gg][Pp][Ss]*) # gps
                toggle_driver_ "" "Gps"
            ;;
        esac
    done
    unset -f toggle_driver_
}

### Run with nvidia
function Nvidia() {
    local -a binary=("$1"); shift
    local -a args=("$@")

    if [[ -z "${binary[*]}" ]]; then
        log error "No binary to execute?"
        return 1
    fi

    if ls -l "${binary[*]}" &> /dev/null; then
        log info "Running from current directory: ./${binary[*]}"
        binary=("./${binary[*]}")
    elif command -v "${binary}" &> /dev/null; then
        log info "Running from PATH: $(whereis -b "${binary[*]}" | cut -d' ' -f2 2> /dev/null)"
        binary=("${binary[*]}")
    else
        log error "${binary[*]}; No such file or binary?"
        return 1
    fi

    local vulkan_icd_path=${VK_ICD_FILENAMES:-"/usr/share/vulkan/icd.d/nvidia_icd.json"}
    local vk_optimus_layer=${__VK_LAYER_NV_optimus:-"NVIDIA_only"}
    local glx_vendor_name=${__GLX_VENDOR_LIBRARY_NAME:-"nvidia"}
    local -i prime_render_offload=${__NV_PRIME_RENDER_OFFLOAD:-1}
    local -i dxvk_hud_setting=${DXVK_HUD:-1}
    local -i mangohud_enabled=${MANGOHUD:-1}

    local -a environment_variables=(
        VK_ICD_FILENAMES=${vulkan_icd_path}
        __VK_LAYER_NV_optimus=${vk_optimus_layer}
        __GLX_VENDOR_LIBRARY_NAME=${glx_vendor_name}
        __NV_PRIME_RENDER_OFFLOAD=${prime_render_offload}
        DXVK_HUD=${dxvk_hud_setting}
        MANGOHUD=${mangohud_enabled}
    )
    # Run executable
    env "${environment_variables[@]}" "${binary[*]}" "${args[@]}"
}; alias nvrun="Nvidia"

### Lauch steam with Nvidia
function Steam() {
    DRI_PRIME=1 __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia steam
}

### Man but cool man
function man() {
    set -o pipefail
    local args=("$@")
    local man_
    man_="$(command -v mandb-man 2> /dev/null || echo /usr/bin/man)"

    { "${man_}" "${args[@]}" | col -b | /usr/bin/bat --decorations=never --pager="less -RF" --color=always --language=markdown; } 2> /dev/null
}

function Font() {
    local font_name="$1"
    fc-list | grep -o -i "${font_name}.*\." | awk -F'.' '{ print $1 }' | tr '-' ' '
}

### Remove Unnecessary characters from given string
function Pretty() {
    for file in "$@"; do
        echo "$file" | sed 's/\[[^]]*\]//g' | sed 's/[^A-Za-z0-9._-$@]/_/g' | sed 's/_\+/_/g' 2> /dev/null
    done
}

### Play directly from Tar files
function TarPlay() {
    local archive="${1}"
    local -a selected=()
    local -a tar_opts=()

    [[ -f "${archive}" ]] || { log error "File not found: '${archive}'"; return 1; }

    case "${archive}" in
        *.tar.gz|*.tgz)  tar_opts=(-z) ;;
        *.tar.bz2|*.tbz2|*.tbz) tar_opts=(-j) ;;
        *.tar.xz|*.txz)  tar_opts=(-J) ;;
        *.tar)           tar_opts=() ;;
        *) log fatal "Unsupported format: ${archive}"; return 1 ;;
    esac

    if [[ -n $ZSH_VERSION ]]; then
        selected="${(@f)$(tar "${tar_opts[@]}" -tf "${archive}" 2>/dev/null | \
            fzf --multi --prompt="Stream from '${archive}' > " --height=20 --border)}" || return 1
    elif [[ -n $BASH_VERSION ]]; then
        mapfile -t selected <(tar "${tar_opts[@]}" -tf "${archive}" 2>/dev/null | \
            fzf --multi --prompt="Stream from '${archive}' > " --height=20 --border) || return 1
    fi

    [[ ${#selected[@]} -ne 0 ]] || { log error "No file selected"; return 0; }

    for file in "${selected[@]}"; do
        while IFS=$'' read -r f; do
            [[ -n "${f}" ]] || continue
            log info "Streaming: ${f}"
            tar "${tar_opts[@]}" -xOf "${archive}" "${f}" 2>/dev/null | \
                mpv --quiet --term-playing-msg='Now playing: ${filename}' -
        done <<< "${file}"
    done
}

### Lauch sway Window manager with vulkan
function sway_vulkan() {
    local -i num_=${1:-0}
    local logfile="/tmp/sway.log"
    if ! "$(find ~/.bin/ -type f -name Sway)" ${num_} &>> "${logfile}"; then
        less -c "${logfile}"
    fi
}

function Cat() {
    local -a args=("${@}")
    bat --theme-dark=TwoDark --color=always --paging=never --decorations=never "${args[@]}" | less -c -
}

function notify() {
    [[ -n $ZSH_VERSION ]] && emulate -LR bash
    local -a args=("${@}")
    local application_name="custom_msg" msg="" notification_type=""
    local title=""
    local -i time=1000
    local -a notification_type_group=( dialog-information system-error )
    notification_type="${notification_type_group[0]}"
    for ((i=0;i<${#args[@]};i++)); do
        # [[ $i -eq 0 ]] && { { [[ -n "${args[0]}" ]] && title="${args[0]:-""}"; } || return 1; continue; }
        # [[ $i -eq 1 ]] && { { [[ -n "${args[1]}" ]] && msg="${args[1]:-""}"; } || return 1; continue; }
        arg="${args[$i]:-""}"
        if [[ "${arg}" == *=* ]]; then
            value="${arg##*=}"
            arg="${arg%%=*}"
        else
            value="${args[$((i+1))]:-""}"
            arg="${arg}"
        fi
        case "${arg}" in
            -t|-*time) time="${value}" ;;
            [0-9]*) time="${arg}" ;;
            type|log*) notification_type="${value}" ;;
            app*|name) application_name="${value}" ;;
            title) title="${value}" ;;
            msg*|mess*) msg="${value}" ;;
            -*help|help*) log info "Usage: ${0##*/} title=[title] msg=[message] [other_args]"; return 0;;
            *) log error "'${arg}' invalid argument"; return 1;;
        esac
    done
    local -a gdbus_cmd=(
        "--session"
        "--dest" "org.freedesktop.Notifications"
        "--object-path" "/org/freedesktop/Notifications"
        "--method" "org.freedesktop.Notifications.Notify"
    )
    gdbus call "${gdbus_cmd[@]}" "${application_name}" 0 "${notification_type}" "${title}" "${msg}" "[]" "{}" "int32 ${time}" 1> /dev/null
}

function start_docker() {
    local -a args=("${@}")
    local data_root="$HOME/data/docker"
    local logfile="/tmp/docker.log"
    local -i should_stop=0 restart_docker=0
    for ((i=0;i<${#args[@]};i++)); do
        arg="${args[$i]}"
        next_arg="${args[$((i+1))]}"
        case "${arg}" in
            stop) should_stop=1 ;;
            -f|-r|-*resart|resart) restart_docker=1 ;;
            -*root) data_root="${next_arg}" ;;
            *) log error "invalid arg: '${arg}'" ;;
        esac
    done

    local -a dockerd_cmd_args=(
        "--debug"
        "--raw-logs"
        "--data-root=${data_root}"
    )

    is_docker_running() {
        pgrep -xf "dockerd ${dockerd_cmd_args[*]}" &> /dev/null
    }
    kill_docker() {
        sudo pkill -SIGTERM -xf "dockerd ${dockerd_cmd_args[*]}"
    }

    if [[ $restart_docker -eq 1 || $should_stop -eq 1 ]]; then
        if is_docker_running; then
            log info "Killing existing process"
            local -i start_time=$(date +%s) timeout=4
            while is_docker_running && [[ $(( $(date +%s) - start_time )) -lt $timeout ]] && sleep 0.12; do kill_docker; done
            [[ $should_stop -eq 1 ]] && { log info "Docker daemon is stopped"; return 0; }
        else
            log error "Docker daemon is not running"
        fi
        [[ $should_stop -eq 1 ]] && return 0
    fi
    sudo mkdir -p "${data_root}"
    { printf '%b' "\n\n\n\n"; for i in {0..20}; do printf '=='; done; printf '%b' "\n"; } | sudo tee "${logfile}" &> /dev/null
    if is_docker_running && [[ $restart_docker -ne 1 ]]; then
        log warn "An instance of docker daemon is already running; use -f or -r to restart"
        return 1
    fi
    sudo bash -c "dockerd ${dockerd_cmd_args[*]} &>> "${logfile}" &> /dev/null & disown"
    timeout 4s bash -c "while ! pgrep -xf \"dockerd ${dockerd_cmd_args[*]}\" &> /dev/null && sleep 0.12; do :; done" || \
        { log error "Failed to find running instance of dockerd; dockerd failed to execute"; return 1; }
    declare -a pid=($(pgrep -xf "dockerd ${dockerd_cmd_args[*]}"))
    log info "Docker started: ${pid[*]}"
    log info "Logs available at '${logfile}'"
    id -nG "${USER}" | grep -q docker || \
        log warn "You are not in the docker group; add yourself to docker group: sudo usermod -aG docker $USER"
}; alias stop_docker="start_docker stop"

### Remove Unnecessary characters from given file
function Pretty_rename() {
    for file in "$@"; do
        mv -- "${file}" "$(printf '%s\n' "${file}" | sed 's/\[[^]]*\]//g' | sed 's/[^A-Za-z0-9._-$@]/_/g' | sed 's/_\+/_/g')" 2> /dev/null
    done
}

### Get randomcolors quickly
function RandomColors() {
    local format="$1"
    pastel random | pastel format "${format:-"hex"}"
}

# yazi filemanager with auto cd
function y() {
    local tmp="$(mktemp)"
    yazi "${@}" --cwd-file=${tmp}
    builtin cd -- "$(<${tmp})"
    rm -f "${tmp}"
}; alias yc="clear; y"

### Start SSH agent on initial login
function SSH_Agent() {
    local ssh_agent="/tmp/.ssh_agent"
    if [[ ! -s "${ssh_agent}" ]]; then
        touch "${ssh_agent}"
        printf '%s\n' "$(ssh-agent -s)" > "${ssh_agent}"
    else
        source "${ssh_agent}" &> /dev/null
    fi
}

function main() {
    Bash_and_ZSH_setup
    SetLocale
    Export_vars
    Alias_vars
    SetPath
    SSH_Agent
}

main "${@}"

