#!/usr/bin/env bash

# Copyright (C) 2026 Rustlog
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# ###############
# @Author: Rustlog
# @Version: v1.0
# @Remote: https://github.com/Rustlog/vjnl
#
# use --help for more
# ###############

builtin set -euo pipefail

D_JOURNAL_DIR="${HOME}/dev/journals"
D_DATA_DIR="${D_JOURNAL_DIR}/data"
D_LOG_DIR="${D_JOURNAL_DIR}/logs"
D_SPLS_DIR="${D_JOURNAL_DIR}/spls"
D_TEMPLATE_DIR="${D_DATA_DIR}/templates"
D_KEY_DIR="${D_DATA_DIR}/keys"
NO_COLOR=1
PAGER=1
LOGLEVEL=2

HOME="${HOME:-$(printf ~)}"
DATE="$(date +%F)"
PROGRAM_NAME="${0##*/}"
F_TRANSFORM_KEY_FILE="${D_KEY_DIR}/key0"
F_TEMPLATE_FILE="${D_TEMPLATE_DIR}/template0"
F_LOG_FILE="${D_LOG_DIR}/${DATE}"
F_JOURNAL_FILE="${D_SPLS_DIR}/default-journal"
# TMP_NAME="$(mktemp -du file.XXXX)"
TMP_NAME="tmp"

VERSION="1.0"
AUTHOR="Rustlog"
LICENSE="GPLv3"
REPO_URL="https://github.com/Rustlog/vjnl"

builtin readonly VERSION AUTHOR LICENSE REPO_URL

builtin readonly HOME DATE PROGRAM_NAME F_TRANSFORM_KEY_FILE F_TEMPLATE_FILE \
    F_LOG_FILE TMP_NAME F_JOURNAL_FILE

# custom pretty logger
function log() {
    local is_debug_enabled=0
    printf '%s\n' "$-" | grep -q "x" && is_debug_enabled=1
    local _type="${1}"; shift
    local _color="" _t=""
    local -i default_level=3

    local -A level=(
        [error]=1
        [fatal]=1
        [warn]=1
        [help_info]=2
        [cmd_info]=2
        [usage]=2
        [info]=2
        [debug]=3
    )

    local -g _info_color="" _warn_color="" _error_color=""
        _fatal_color="" _other_color="" _nc=""
    _info_color="" _warn_color="" _error_color="" _fatal_color="" _other_color="" _nc=""
    is_flag_disabled "$NO_COLOR" && _info_color="\033[38;2;85;255;126m" \
        _warn_color="\033[38;2;255;170;10m" _error_color="\033[38;2;244;29;31m" \
        _fatal_color="\033[5m\033[38;2;255;0;0m" _other_color="\033[38;2;251;255;208m" \
        _nc="\033[0m"

    case "${_type}" in
        info) _color="${_info_color:-}" _t="*"      ;;
        warn) _color="${_warn_color:-}" _t="^"      ;;
        error) _color="${_error_color}" _t="!"      ;;
        fatal) _color="${_fatal_color:-}" _t="#"    ;;
        *) _color="${_other_color-""}" _t=""        ;;
    esac

    severity="${level[${_type}]:-${default_level}}"

    { is_flag_enabled "${is_debug_enabled}" && set -x; } || true
    (( LOGLEVEL >= severity )) || return 0

    printf "[%b%s%b%s]: %b\n" \
        "${_color}" "${_type}" "${_nc}" "${_t}" "${*//$HOME/\~}"
    return 0
}

# helpful usage message
function ShowUsage() {
    FULL_USAGE="${FULL_USAGE:+full}"
    local help_length="${1:-${FULL_USAGE:-short}}"

    log debug "show help menu"

    local green="" light_brown="" gray="" bold="" nc=""

    is_flag_disabled "$NO_COLOR" && green="\033[38;2;100;200;30m" light_brown="\033[38;2;212;184;142m" \
        gray="\033[38;2;140;140;140m" bold="\033[1m" nc="\033[0m"

    printf '%b\n' \
        "${bold}${light_brown}usage:${nc} ${green}${PROGRAM_NAME}${nc} [global options] [action] [options]" \
        "${bold}${light_brown}actions:${nc}" \
        "   edit-journal            edit journal for given or current date" \
        "   edit-template           edit template" \
        "   show-journal            show journal" \
        "   show-template           show template" \
        "   edit                    infer edit operation smartly" \
        "   show                    infer show operation smartly" \
        "   cat                     concatenate give journal/template" \
        "   list                    list contents of a directory (see --full-help)" \
        "   delete                  delete given journal/template" \
        "   rename                  rename given journal/template" \
        "   copy                    copy given journal/template" \
        "${light_brown}options:${nc}" \
        "   -j|--journal            select journal" \
        "   -l|--log                select log" \
        "   -t|--template           select template" \
        "   -u|--use                use given content" \
        "${light_brown}global options:${nc}" \
        "   --loglevel              set loglevel (0-4)" \
        "   --verbose               enable verbose mode (loglevel 3)" \
        "   --no-pager              disable pager" \
        "   --color                 enable colors for subsequent operation" \
        "   --no-color              disable colors for subsequent operation" \
        "   --version               show package version" \
        "   --author                show author name" \
        "   --tree-view             tree view of journal directory" \
        "   --license               show license of this tool" \
        "   --repo                  show repo url" \
        "   --about                 show metadata about this package" \
        "   --help                  show this help" \
        "${light_brown}notes:${nc}" \
        "   journals live here (${D_JOURNAL_DIR//$HOME/\~})."
    [[ "${help_length}" == "full" ]] || \
        { printf '%b\n' "   use --full-help for more.\n" ; return 1; }
    local n="${PROGRAM_NAME}"
    printf '%b\n' \
        "   'edit-journal', 'edit-template', 'edit-log' can be used to create new" \
        "       entries and immediately edit em. afterwards just 'edit' is fine." \
        "       starter example: ${green}${n}${nc} edit-log day=today -t default -c 'special day: ...'" \
        "   'edit' and 'show' are more generic, so only existing" \
        "       entries can be edited or shown." \
        "    Supports consistent task separated actions: edit-*, copy-*, move-*, rename-* & delete-* ." \
        "    when creating a journal; '-t' and '-u' are often interchangeable" \
        "       -u takes priority when both given" \
        "    when creating a template; '-t' may specify a name; '-u' provides initial content" \
        "       (literal strings, file path, or another template)" \
        "    comments can be attached to any logs/journal/template." \
        "    day= syntax allows specifying the journal date flexibly:" \
        "       day=tomorrow / day=yesterday   -> GNU-style relative days, (any valid \`date -d 'string'\`)" \
        "       day=+N                         -> GNU-style N days relative to today" \
        "       day=+Nd / day=-Nd              -> BSD-style relative days (with -v)" \
        "       day='-v +3d'                   -> raw date flags passed directly (advanced usage)" \
        "${light_brown}examples:${nc}" \
        "   ${gray}# creating and editing journals/templates${nc}" \
        "       ${gray}# create/re-use journal and edit${nc}" \
        "           ${green}${n}${nc} edit-journal todo" \
        "           ${green}${n}${nc} edit todo ${gray}# afterwards just 'edit' is fine${nc}" \
        "       ${gray}# create/re-use and edit journal with default template${nc}" \
        "           ${green}${n}${nc} edit-journal todo -t default" \
        "       ${gray}# create/re-use template and edit using default template${nc}" \
        "           ${green}${n}${nc} edit-template template1 -t default" \
        "       ${gray}# fill existing template to new journal${nc}" \
        "           ${green}${n}${nc} edit-journal todo-project -t t1" \
        "   ${gray}# create custom templates${nc}" \
        "       ${gray}# create blank template (no content)${nc}" \
        "           ${green}${n}${nc} edit-template" \
        "       ${gray}# create new default (template0) template using default contents (supports --comment)${nc}" \
        "           ${green}${n}${nc} edit-template -t default -u default" \
        "   ${gray}# delete / copy / rename / listing & viewing${nc}" \
        "       ${gray}# file navigation${nc}" \
        "           ${green}${n}${nc} copy life life_backup     ${gray}# clone life${nc}" \
        "           ${green}${n}${nc} delete life               ${gray}# delete life :(${nc}" \
        "           ${green}${n}${nc} rename life_backup life   ${gray}# revive life :)${nc}" \
        "       ${gray}# pretty print the content of journal or template${nc}" \
        "           ${green}${n}${nc} show todo-project            ${gray}# pager enabled by default${nc}" \
        "           ${green}${n}${nc} --no-pager show todo-project ${gray}# disable pager${nc}" \
        "           ${green}${n}${nc} cat todo-project             ${gray}# concatenate${nc}" \
        "       ${gray}# list content of known directories (available options: logs/journals/templates)${nc}" \
        "           ${green}${n}${nc} list logs                    ${gray}# dated logs in logs/ dir with comments${nc}" \
        "   ${gray}# extras${nc}" \
        "           ${gray}# create new & use default template & add a inline comment${nc}" \
        "       ${green}${n}${nc} edit-journal project-work -t default -c 'projects related plans'" \
        "           ${gray}# create new & use given template & add a inline comment${nc}" \
        "       ${green}${n}${nc} edit-journal prod-script -t /path/to/my/template_file -c 'design and behaviour of prod script'" \
        ""
}

# helper for fetching metadata about this tool
function ShowInfo() {
    local info_type="${1:-version}"
    case "${info_type}" in
        version)    printf '%s\n' "${VERSION}" ;;
        author)     printf '%s\n' "${AUTHOR}" ;;
        license)    printf '%s\n' "${LICENSE}" ;;
        repo)       printf '%s\n' "${REPO_URL}" ;;
        all)        printf '%s\n' "Version: ${VERSION}" "Author: ${AUTHOR}"  \
                        "License: ${LICENSE}" "Repo url: ${REPO_URL}" ;;
    esac
}

# Update program itself
function UpdateProgram() {
    local program_realpath
    local url="https://raw.githubusercontent.com/${AUTHOR}/${PROGRAM_NAME}/main/bin/${PROGRAM_NAME}"
    program_realpath="$(readlink -f "${0}")"
    program_name="${program_realpath##*/}" program_dir="${program_realpath%/*}"
    log cmd_info "$(ColorCMD "cd ${program_dir}")"
    cd "${program_dir}" || { log error "failed to chdir to '${program_dir}'"; return 1; }
    if command -v "curl" &> /dev/null; then
        log cmd_info "$(ColorCMD "sudo curl -f#SLC- -o ./${program_name}.download ${url}")"
        sudo curl -"f#SLC-" -o ./"${program_name}.download" "${url}" || \
            { log error "failed to download program '${program_name}'"; return 1; }
    elif command -v "wget" &> /dev/null; then
        log cmd_info "$(ColorCMD "sudo wget -nv \
--show-progress --progress=bar:force --continue --output-document=./${program_name}.download ${url}")"
        sudo wget -nv --show-progress \
            --progress=bar:force --continue \
            --output-document=./"${program_name}.download" "${url}" || \
            { log error "failed to download program '${program_name}'"; return 1; }
    else
        log error "'curl' or 'wget' not found on system to update the program"; return 1
    fi
    sudo mv ./"${program_name}.download" "${program_name}" || \
        { log error "failed to move program '${program_name}.download' '${program_name}'"; return 1; }
}

# Pornify commands with asm
function ColorCMD() {
    ! command -v bat &> /dev/null && { printf '%b\n' "${1//$HOME/\~}"; return 0; }
    bat --color="$( \
        is_flag_disabled "$NO_COLOR" && \
        printf '%s\n' always || printf '%s\n' never \
    )" --decorations=never \
        --paging=never --language=asm <<< "${1//$HOME/\~}"
}

# HELPER function -- Check enabled state
function is_flag_enabled() {
    local -i var=${1}
    [[ "$var" -eq 1 ]] && return 0
    return 1
}

# HELPER function -- Check disabled state
function is_flag_disabled() {
    local -i var=${1}
    [[ "$var" -eq 0 ]] && return 0
    return 1
}

# HELPER function -- Check enabled state
function are_flags_enabled() {
    local -a vars=("${@}")
    for var in "${vars[@]}"; do
        [[ "$var" -eq 1 ]] && continue
        return 1
    done
}

# HELPER function -- Check enabled state
function are_flags_disabled() {
    local -a vars=("${@}")
    for var in "${vars[@]}"; do
        [[ "$var" -eq 0 ]] && continue
        return 1
    done
}

# HELPER function -- Check file existance
function require_file() {
    local file="${1}" _type="${2:-}" msg="${3:-}"
    [[ -s "${file}" && -f "${file}" ]] && return 0
    [[ -n "${msg}" ]] && log "${_type}" "${msg}"
    return 1
}

# HELPER function -- Check file existance
function require_regular_file() {
    local file="${1}" _type="${2:-}" msg="${3:-}"
    [[ -f "${file}" ]] && return 0
    [[ -n "${msg}" ]] && log "${_type}" "${msg}"
    return 1
}

# HELPER function -- Variable is not empty
function require_var() {
    local var="${1:-}" _type="${2:-}" msg="${3:-}"
    [[ -n "${var}" ]] && return 0
    [[ -n "${msg}" ]] && log "${_type}" "${msg}"
    return 1
}

# HELPER function -- Variable is not empty
function is_var_empty() {
    local var="${1:-}" _type="${2:-}" msg="${3:-}"
    [[ -n "${var}" ]] || return 0
    [[ -n "${msg}" ]] && log "${_type}" "${msg}"
    return 1
}

# HELPER function -- Print given path
function print_path() {
    local dir="${1:-}" name="${2:-}"
    require_var "${dir}" || return 1
    require_var "${name}" || return 1
    case "${what}" in
        "full_path") printf '%s\n' "${dir}/${name}" ;;
        *)           printf '%s\n' "${dir}"         ;;
    esac
}

# HELPER function -- Print given path
function resolve_path() {
    local -n var_ref
    local which_type="${1:-}" name="${2:-}"
    var_ref=${3}
    case "${which_type}" in
        journal) var_ref="$(DispatchPath journal "${name}" no)" || \
    { log error "failed to select appropriate journal file '${name}'"; return 1; } ;;
        log) var_ref="$(DispatchPath log "${name}" no)" || \
    { log error "failed to select appropriate log file '${name}'"; return 1; } ;;
        template) var_ref="$(DispatchPath template "${name}")" || \
    { log error "failed to select appropriate template file '${name}'"; return 1; } ;;
        guess) var_ref="$(DispatchPath guess "${name}")" || \
    { log error "failed to select appropriate file '${name}'"; return 1; } ;;
        *) log error "anything else is not welcome."; return 1 ;;
    esac
}

# blank template with date only
function BlankTemplate() {
    local -i is_debug_enabled=0
    printf '%s\n' "$-" | grep -q "x" && is_debug_enabled=1
    { is_flag_enabled "${is_debug_enabled}" && set +x; } || true
    cat << EOF
# $(date +"Date: %F, Created on: %T (%I:%M:%S_%p)")

EOF
    { is_flag_enabled "${is_debug_enabled}" && set -x; } || true
}

# default template as starter
function DefaultTemplate() {
    local -i is_debug_enabled=0
    printf '%s\n' "$-" | grep -q "x" && is_debug_enabled=1
    { is_flag_enabled "${is_debug_enabled}" && set +x; } || true
    cat << EOF
# $(date +"Date: %F, Created on: %T (%I:%M:%S_%p)")

## @@ dump @@
(just raw thoughts)

## @@ what matters today @@
( elaborate )

## @@ work/moves @@
-
-
-

## @@ notes/scratch @@
(anything: ideas, errors, thoughts)

## @@ insights @@
(something: observed, impactful)

## @@ end @@
done:
still open:
tomorrow:
maybe tomorrow:

# vim: sts=4 sw=4 ft=vdf et:

EOF
    { is_flag_enabled "${is_debug_enabled}" && set -x; } || true
}

# generate a chipher key for default key
function GenerateKey() {
    log debug "generate key"
    { printf '%s\n' {{A..Z},{a..z}} | shuf | tr -d '\n'; } \
        &> "${F_TRANSFORM_KEY_FILE}" || \
            log error "failed to generate key"
    log info "new key generated at '${F_TRANSFORM_KEY_FILE}'"
}

# tree view of your journal directory
function TreeView() {
    log deug "tree view of '${D_JOURNAL_DIR}'"
    output="$(tree -C "${D_JOURNAL_DIR}")"
    printf '%b\n' "${output//$HOME/\~}"
}

# substiution chipher (encode)
function EncodeFile() {
    local file1="${1:-}" file2="${2:-}"
    log debug "encode file '${file1}'"
    require_file "${F_TRANSFORM_KEY_FILE}" || GenerateKey
    require_var "${file1}" || \
        { log error "cannot decode: no file1 given"; return 1; }
    require_var "${file2}" || \
        { log error "cannot decode: no file2 given"; return 1; }
    if ! tr 'A-Za-z' "$(<"${F_TRANSFORM_KEY_FILE}")" &> "${file2}" < "${file1}"; then
        log error "EncodeFile(): failed to apply cipher"
    fi
}

# substiution chipher (encode)
function DecodeFile() {
    local file1="${1:-}" file2="${2:-}"
    log debug "decode file '${file1}'"
    require_file "${F_TRANSFORM_KEY_FILE}" || GenerateKey
    require_var "${file1}" || \
        { log error "cannot decode: no file1 given"; return 1; }
    require_var "${file2}" || \
        { log error "cannot decode: no file2 given"; return 1; }
    if ! tr "$(<"${F_TRANSFORM_KEY_FILE}")" 'A-Za-z' &> "${file2}" < "${file1}"; then
        log error "DecodeFile(): failed to apply cipher"
    fi
}

# smart journal edit
function EditJournal() {
    local which_type="${1:-}" journal_name="${2:-}" template="${3:-}" \
        content="${4:-}" comment="${5:-}"
    local journal_dir="" tmp_file="" file=""

    require_var "${which_type}" || \
        { log error "${FUNCNAME[0]}(): cannot edit without a valid type" \
            "(log/journal/guess)"; return 1; }

    if ! [[ "${which_type}" =~ ^(journal|log|guess)$ ]]; then
        log errror "${FUNCNAME[0]}(): invalid type '${which_type}'"; return 1
    fi

    if require_regular_file "${journal_name}"; then
        journal_file="${journal_name}"
    else
        if [[ "${which_type}" == guess ]]; then
            if ! { found_file="$(DispatchPath journal "${journal_name}" yes)" || \
                found_file="$(DispatchPath log "${journal_name}" yes)"; }; then
                    { log error "${FUNCNAME[0]}(): failed to edit" \
                        "'${journal_name}': try edit-* commands to create"; return 1; }
            fi
        else
            found_file="$(DispatchPath "${which_type}" "${journal_name}" no)" || \
                { log error "${FUNCNAME[0]}(): failed to select" \
                    "${which_type}: '${journal_name}'"; return 1; }
        fi
    fi

    journal_file="${found_file:-${journal_file:-}}"

    require_var "${journal_file}" || \
        { log error "${FUNCNAME[0]}(): cannot edit; not file given"; return 1; }

    journal_dir="${journal_file%/*}" journal_name="${journal_file##*/}"
    tmp_file="${journal_dir}/${journal_name}.${TMP_NAME}" file=""

    log debug "using journal '${journal_file}'"

    touch "${tmp_file}" && chmod 0600 "${tmp_file}"
    require_file "${F_TRANSFORM_KEY_FILE}" || GenerateKey
    if require_file "${journal_file}"; then
        DecodeFile "${journal_file}" "${tmp_file}"
        log info "editing journal '${journal_file}'"
        "${EDITOR:-vim}" "${tmp_file}" || log error "editor returned failed status"
        EncodeFile "${tmp_file}" "${journal_file}"
        rm -f "${tmp_file}" &> /dev/null; return 0
    fi
    require_var "${content}" && template="${content}"
    if require_var "${template}"; then
        if [[ -s "${template}" ]]; then
            log debug "copying template '${template}' to '${tmp_file%.*}'"
            cp "${template}" "${tmp_file}"
        elif [[ "${template}" == "default" ]]; then
            log debug "using default template"
            DefaultTemplate &> "${tmp_file}"
        elif [[ "${template}" == "blank" ]]; then
            log debug "using blank template"
            BlankTemplate &> "${tmp_file}"
        elif [[ "${template}" == "${D_TEMPLATE_DIR}/${template}" ]]; then
            log debug "copying template '${D_TEMPLATE_DIR}/${template}' to '${tmp_file%.*}'"
            cp "${D_TEMPLATE_DIR}/${template}" "${tmp_file}"
        else
            if file="$(FindTemplate "${template}")"; then
            { require_file "${file}" && cp "${file}" "${tmp_file}"; } || \
                { log error "template doesn't exist or empty '${file}'"; return 1; }
            else
                log debug "using user given template"
                printf '%s\n' "${template}" &> "${tmp_file}"
            fi
        fi
    else
        # DefaultTemplate &> "${tmp_file}"
        log debug "using blank template"
        BlankTemplate &> "${tmp_file}"
    fi
    log info "editing journal '${journal_file}'"
    if require_var "${comment}"; then
        comment="#comment|${comment}|"
        sed -i "2a${comment}\n" "${tmp_file}"
    fi
    "${EDITOR:-vim}" "${tmp_file}" || log error "editor returned failed status"
    EncodeFile "${tmp_file}" "${journal_file}"
    rm -f "${tmp_file}" &> /dev/null; return 0
}

# edit tempalte
function EditTemplate() {
    local template_name="${1:-}" use_template="${2:-}" comment="${3:-}"
    local template_file=""

    require_var "${template_name}" || \
        { log error "cannot edit template: no template given"; return 1; }

    if require_regular_file "${template_name}"; then
        template_file="${journal_name}"
    elif ! template_file="$(DispatchPath template "${template_name}")"; then
        template_file="${D_TEMPLATE_DIR}/${template_name}"
    fi

    template_file="${template_file:-${F_TEMPLATE_FILE}}"

    log debug "using template '${template_file}'"

    if require_file "${template_file}"; then
        log info "editing template '${template_file}'"
        "${EDITOR:-vim}" "${template_file}"; return 0
    fi

    if require_file "${use_template}"; then
        log debug "using user given template '${use_template}'"
        cp "${use_template}" "${template_file}"
    else
        if [[ "${use_template}" == "default" ]]; then
            log debug "using default template'${use_template}'"
            DefaultTemplate &> "${template_file}"
        elif [[ "${use_template}" == "blank" ]]; then
            log debug "using blank template"
            BlankTemplate &> "${tmp_file}"
        else
            printf '%s\n' "${use_template}" &> "${template_file}"
        fi
    fi
    log info "editing template '${template_file}'"
    if require_var "${comment}"; then
        comment="#comment|${comment}|"
        sed -i "2a${comment}\n" "${template_file}"
    fi
    "${EDITOR:-vim}" "${template_file}"
}

# pretty print given file
function PrettyPrintFile() {
    local which_type="${1:-}" given_name="${2:-}" method="${3:-pager}"
    local should_decode="" found_file=""

    require_var "${which_type}" || \
        { log error "${FUNCNAME[0]}(): cannot show/cat without a valid type" \
            "(log/journal/template/guess)"; return 1; }

    if ! [[ "${which_type}" =~ ^(journal|log|template|guess)$ ]]; then
        log errror "${FUNCNAME[0]}(): invalid type '${which_type}'"; return 1
    fi

    found_file="$(DispatchPath "${which_type}" "${given_name}")" || \
        { log error "${FUNCNAME[0]}(): failed to select '${which_type}: ${given_name}'"; return 1; }

    require_regular_file "${found_file}" || \
        { log error "${FUNCNAME[0]}(): failed to concatenate ${which_type}" \
            "'${given_name}'"; return 1; }

    local using_dir="${found_file%/*}" journal_name="${found_file##*/}"
    local use_file="${found_file}" color="never"

    is_flag_enabled "$NO_COLOR" || color="always"
    is_flag_enabled "$PAGER" || method="unknown"

    if [[ "${method}" == pager ]];then
        log info "viewing '${found_file}'"
    elif [[ "${method}" == cat ]];then
        log info "concatenating '${found_file}'"
    else
        log info "showing '${found_file}'"
    fi

    if require_regular_file "${found_file}"; then
        if ! require_file "${found_file}"; then
            log warn "${FUNCNAME[0]}(): '${found_file}' is empty"; return 1
        fi
    fi

    [[ "${using_dir:$((${#using_dir}-1)):1}" == "/" ]] && using_dir="${using_dir:0:-1}"

    if [[ "${using_dir}" =~ ^(${D_LOG_DIR}|${D_SPLS_DIR})$ ]]; then
        should_decode=yes
    else should_decode=no
    fi

    if [[ "${should_decode}" == "yes" ]]; then
        use_file="${using_dir}/${journal_name}.${TMP_NAME}"
        touch "${use_file}" && chmod 0600 "${use_file}"
        DecodeFile "${found_file}" "${use_file}"
    fi
    if command -v "bat" &> /dev/null; then
        if is_flag_enabled "$PAGER" && [[ "${method}" == pager ]] && \
                command -v "less" &> /dev/null; then
            bat --decorations=never --paging=never \
                --color="${color}" --language=bash "${use_file}" | less -c -
        else
            bat --decorations=never --paging=never \
                --color="${color}" --language=bash "${use_file}"
        fi
    else
        if is_flag_enabled "$PAGER" && [[ "${method}" == pager ]] && \
            command -v "less" &> /dev/null; then
            less -c "${use_file}"
        else
            cat "${use_file}"
        fi
    fi
    [[ "${should_decode}" == "yes" ]] && { EncodeFile "${use_file}" "${found_file}"; \
        rm -f "${use_file}" 2> /dev/null; }
}

function ListDirectory() {
    local list_what="${1:-}"
    local dir="" comment="" file_name="" file="" key="" \
        pattern="#comment|.*|"
    local -i should_decode=0
    local -a available_files=()
    if [[ "${list_what}" == journal* ]]; then
        dir="${D_SPLS_DIR}" key="$(<"${F_TRANSFORM_KEY_FILE}")"
        should_decode=1 pattern="$(tr 'A-Za-z' "${key}" <<< "${pattern}")"
    elif [[ "${list_what}" == log* ]]; then
        dir="${D_LOG_DIR}" key="$(<"${F_TRANSFORM_KEY_FILE}")"
        should_decode=1 pattern="$(tr 'A-Za-z' "${key}" <<< "${pattern}")"
    elif [[ "${list_what}" == template* ]]; then
        dir="${D_TEMPLATE_DIR}"
    else
        log error "could not find associated directory for the request '${list_what}'"
        return 1
    fi
    require_var "$(find "${dir}" -mindepth 1 -maxdepth 1 -print -quit)" || \
        { log warn "directory is empty (${dir})"; return 1; }
    mapfile -t available_files < <(find "${dir}" -mindepth 1 -maxdepth 1 -printf "%p\n")
    log info "available ${list_what} (${dir})"
    for file in "${available_files[@]}"; do
        file_name="${file##*/}"
        comment="$(grep -o "${pattern}" "${file}" | cut -d'|' -f2 || true)"
        [[ "$should_decode" -eq 1 ]] && comment="$(tr "${key}" 'A-Za-z' <<< "${comment}")"
        comment="${comment:+(${comment})}"
        printf '    %-35s %-20s\n' "${file_name}" "${comment:-[no comment]}"
    done
}

# delete a file
function DeleteFile() {
    local f_file="${1:-}" t_status="${2:-removed}"
    local dir=""
    dir="${f_file%/*}"
    file_name="${f_file##*/}"
    require_regular_file "${f_file}" || \
        { log error "delete failed: no such file '${f_file}'"; return 1; }
    cd "${dir}" || { log error "failed chdir to '${dir}'"; return 1; }
    rm ./"${file_name}" || { log error "failed to remove '${file_name}'"; return 1; }
    log info "${t_status} '${file_name}'"
    return 0
}

# copy/rename a file
function FileDo() {
    local operation="${1:-}" name1="${2:-}" name2="${3:-}"
    local f_path="" dir=""
    local t_status="" t_op="" comm=""

    case "${operation}" in
        copy)
            resolve_path guess "${name1}" f_path
            t_status="copied" t_op="copy" comm="cp"                 ;;
        rename|move)
            resolve_path guess "${name1}" f_path
            t_status="${operation}d" t_op="${operation}" comm="mv"  ;;
        delete)
            resolve_path guess "${name1}" f_path || return 1
            t_status="removed"
            DeleteFile "${f_path}" "${t_status}" || return 1
            return 0                                                ;;
        copy[_-]journal)
            resolve_path journal "${name1}" f_path
            t_status="journal copied" t_op="copy" comm="cp"         ;;
        copy[_-]template)
            resolve_path template "${name1}" f_path
            t_status="template copied" t_op="copy" comm="cp"        ;;
        copy[_-]log)
            resolve_path log "${name1}" f_path
            t_status="log copied" t_op="copy" comm="cp"             ;;
        move[_-]journal)
            resolve_path journal "${name1}" f_path
            t_status="journal moved" t_op="move" comm="mv"          ;;
        move[_-]template)
            resolve_path template "${name1}" f_path
            t_status="template moved" t_op="move" comm="mv"         ;;
        move[_-]log)
            resolve_path log "${name1}" f_path
            t_status="log moved" t_op="move" comm="mv"              ;;
        rename[_-]journal)
            resolve_path journal "${name1}" f_path
            t_status="journal renamed" t_op="rename" comm="mv"      ;;
        rename[_-]template)
            resolve_path template "${name1}" f_path
            t_status="template renamed" t_op="rename" comm="mv"     ;;
        rename[_-]log)
            resolve_path log "${name1}" f_path
            t_status="log renamed" t_op="rename" comm="mv"          ;;
        delete[_-]journal)
            resolve_path journal "${name1}" f_path || return 1
            t_status="removed journal"
            DeleteFile "${f_path}" "${t_status}" || return 1
            return 0                                                ;;
        delete[_-]log)
            resolve_path log "${name1}" f_path || return 1
            t_status="removed log"
            DeleteFile "${f_path}" "${t_status}" || return 1
            return 0                                                ;;
        delete[_-]template)
            t_status="removed template"
            resolve_path template "${name1}" f_path || return 1
            DeleteFile "${f_path}" "${t_status}" || return 1
            return 0                                                ;;
        *) return 1                                                 ;;
    esac

    require_var "${name2}" || return 1

    log debug "${operation} '${name1}' -> '${name2}'"

    dir="${f_path%/*}"

    cd "${dir}" || { log error "failed chdir to '${dir}'"; return 1; }
    require_regular_file "${name1}" || { log error \
        "${t_op} failed: no such file '${name1}'"; return 1; }
    "${comm}" ./"${name1}" "${name2}" || \
        { log error "failed ${t_op} '${name1}' to '${name2}'"; return 1; }
    log info "${t_status} '${name1}' -> '${name2}'"
    return 0
}

# search template name in path
function FindTemplate() {
    local template_name="${1:-}"
    require_var "${template_name}" || return 1
    if require_file "${template_name}"; then
        printf '%s\n' "${template_name}"; return 0
    elif [[ "${template_name}" == "default" ]] ; then
        printf '%s\n' "${F_TEMPLATE_FILE}"; return 0
    elif require_regular_file "${D_TEMPLATE_DIR}/${template_name}"; then
        printf '%s\n' "${D_TEMPLATE_DIR}/${template_name}"; return 0
    else
        return 1
    fi
}

# search journal name in path
function FindJournal() {
    local journal_name="${1:-}"
    local what="${2:-full_path}"
    require_var "${journal_name}" || return 1
    if require_regular_file "${journal_name}"; then
        print_path "${journal_name%/*}" "${journal_name##*/}"; return 0
    elif require_regular_file "${D_SPLS_DIR}/${journal_name}"; then
        print_path "${D_SPLS_DIR}" "${journal_name}"; return 0
    else return 1
    fi
}

# search log name in path
function FindLog() {
    local log_name="${1:-}"
    local what="${2:-full_path}"
    require_var "${log_name}" || return 1
    if require_regular_file "${log_name}"; then
        print_path "${log_name%/*}" "${log_name##*/}"; return 0
    elif [[ "${log_name}" =~ ^(today|${DATE}|default)$ ]]; then
        print_path "${D_LOG_DIR}" "${DATE}"
    elif require_regular_file "${D_LOG_DIR}/${log_name}"; then
        print_path "${D_LOG_DIR}" "${log_name}"; return 0
    elif [[ "${log_name}" == *=* ]]; then
        local -a date_flags=()
        log_name="${log_name##*=}"
        if [[ "${log_name}" =~ ^[+-][0-9]+d$ ]]; then
            date_flags+=(-v "${log_name}")
        elif [[ "${log_name}" =~ ^[+-][0-9]+$ ]]; then
            date_flags+=(-d "${log_name} day")
        elif [[ "${log_name}" == -* ]]; then
            date_flags+=( ${log_name:+ ${log_name}} )
        elif [[ "${log_name}" =~ ^[A-Za-z].*$ ]]; then
            date -d "${log_name}" +%F &>/dev/null || return 1
            date_flags+=(-d "${log_name}")
        fi
        (( ${#date_flags[@]} )) || return 1
        print_path "${D_LOG_DIR}" "$(date "${date_flags[@]}" +%F)"
    else return 1
    fi
}

# select journal/template then try a guess
function DispatchPath() {
    local which_type="${1:-guess}" name="${2:-}" should_file_exist="${3:-yes}"
    local f_path=""
    require_var "$name" || return 1
    if [[ "${which_type}" == journal && "${name}" == default ]]; then
        printf '%s\n' "${F_JOURNAL_FILE}"; return 0
    elif [[ "${which_type}" == template && "${name}" == default ]]; then
        printf '%s\n' "${F_TEMPLATE_FILE}"; return 0
    elif [[ "${which_type}" == log && "${name}" == default ]]; then
        printf '%s\n' "${F_LOG_FILE}"; return 0
    elif [[ "${which_type}" == journal ]]; then
        f_path="$(FindJournal "${name}")" || \
            f_path="${D_SPLS_DIR}/${name}"
        [[ "${should_file_exist}" == yes ]] && \
            { require_regular_file "${f_path}" || return 1; }
        printf '%s\n' "${f_path}"; return 0
    elif [[ "${which_type}" == template ]]; then
        f_path="$(FindTemplate "${name}")" || \
            f_path="${D_TEMPLATE_DIR}/${name}"
        [[ "${should_file_exist}" == yes ]] && \
            { require_regular_file "${f_path}" || return 1; }
        printf '%s\n' "${f_path}"; return 0
    elif [[ "${which_type}" == log ]]; then
        f_path="$(FindLog "${name}")" || \
            f_path="${D_LOG_DIR}/${name}"
        [[ "${should_file_exist}" == yes ]] && \
            { require_regular_file "${f_path}" || return 1; }
        printf '%s\n' "${f_path}"; return 0
    else
        { f_path="$(FindJournal "${name}")" || \
            f_path="$(FindLog "${name}")" || \
                f_path="$(FindTemplate "${name}")"; } || return 1
        [[ "${should_file_exist}" == yes ]] && \
            { require_regular_file "${f_path}" || return 1; }
        printf '%s\n' "${f_path}"; return 0
    fi
}

# Entry point
function main() {
    local -a args=("${@}")

    # Booleans
    local -i edit_journal=0 show_something=0 show_journal=0 select_template=0 \
        edit_journal=0 edit_something=0 select_journal=0 edit_template=0 \
        show_template=0 show_journal=0 list_journals=0 list_templates=0 \
        cat_something=0 cat_template=0 cat_journal=0 cat_log=0 edit_log=0 \
        show_log=0 select_log=0

    # pre-declared temporary variables
    local name="" name1="" name2="" dir="" comment_string="" list_something_value="" \
        show_something_value="" edit_something_value="" cat_something_value="" \
        f_path=""

    local journal_name="" template_name="" log_name="" t_content=""

    [[ -t 1 ]] && NO_COLOR=0

    consume_val() {
        local -n var_ref index_ref
        var_ref=${1} index_ref=${3}
        local value="${2:-}"
        [[ -n "${value}" && "${value}" != -* ]] || return 0
        # shellcheck disable=SC2034
        var_ref="${value}" index_ref=$((index_ref+1))
    }

    # custom hand rolled parser
    local arg="" value="" m=""
    local -i i=0
    for ((i=0;i<${#args[@]};i++)); do
        arg="${args[i]}"

        if is_var_empty "${m}"; then
            [[ $((${#args[@]}-i)) -ge 1 && -n "${args[i+1]:-}" ]] && \
                value="${args[i+1]}"
            if [[ "${arg}" == *=* ]]; then
                value="${arg#*=}" arg="${arg%%=*}"
                [[ -n "${value}" ]] || \
                    { log error "'${arg}' requires a value"; return 1; }
                i=$((i-1))
            fi
            case "${arg}" in
                cat) consume_val    cat_something_value "${value}" i
                    cat_something=1 m="${arg}"              ;;
                edit) consume_val   edit_something_value "${value}" i
                    edit_something=1 m="${arg}"             ;;
                show) consume_val   show_something_value "${value}" i
                    show_something=1 m="${arg}"             ;;
                cat[_-]template)    consume_val cat_something_value "${value}" i
                    cat_template=1 m="${arg}"               ;;
                cat[_-]journal)     consume_val cat_something_value "${value}" i
                    cat_journal=1 m="${arg}"                ;;
                cat[_-]log)         consume_val cat_something_value "${value}" i
                    cat_log=1 m="${arg}"                    ;;
                edit[_-]journal)    consume_val edit_something_value "${value}" i
                    edit_journal=1 m="${arg}"               ;;
                edit[_-]template)   consume_val edit_something_value "${value}" i
                    edit_template=1 m="${arg}"              ;;
                edit[_-]log)        consume_val edit_something_value "${value}" i
                    edit_log=1 m="${arg}"                   ;;
                show[_-]journal)    consume_val show_something_value "${value}" i
                    show_journal=1 m="${arg}"               ;;
                show[_-]template)   consume_val show_something_value "${value}" i
                    show_template=1 m="${arg}"              ;;
                show[_-]log)        consume_val show_something_value "${value}" i
                    show_log=1 m="${arg}"                   ;;
                list) consume_val list_something_value "${value}" i;
                    m="${arg}"                              ;;
                list[_-]journal*)
                    list_journals=1 m="${arg}"              ;;
                list[_-]template*)
                    list_templates=1 m="${arg}"             ;;
                delete*)
                    require_var "${value}" && i=$((i+1))
                    require_var "${value}" || { log error \
                        "do: ${PROGRAM_NAME} ${arg} [name]"; return 1; }
                    FileDo "${arg}" "${value}" || return 1
                    return 0                            ;;
                copy|rename|move|copy*|rename*|move*)
                    require_var "${value}" && i=$((i+1))
                    [[ ( $((${#args[@]}-i)) -ge 1 && \
                        ( -n "${args[i+1]:-}" && "${args[i+1]:-}" != -* ) ) && -n "${value}" ]] || \
                            { log error "do: ${PROGRAM_NAME} ${arg} [old_name] [new_name]"; return 1; }
                    name1="${value}" name2="${args[i+1]}" i=$((i+1))
                    FileDo "${arg}" "${name1}" "${name2}" || return 1
                    return 0                                            ;;
                --tree*)  TreeView; return 0                            ;;
                --paging|--pager)       PAGER=1                         ;;
                --no-paging|--no-pager) PAGER=0                         ;;
                --color)                NO_COLOR=0                      ;;
                --no-color)             NO_COLOR=1                      ;;
                --full-help) ShowUsage full; return 0                   ;;
                --help) ShowUsage; return 0                             ;;
                -v|--version) ShowInfo version; return 0                ;;
                --author) ShowInfo author; return 0                     ;;
                --license) ShowInfo license; return 0                   ;;
                --showinfo|--show-info|--about) ShowInfo all; return 0  ;;
                --repo) ShowInfo repo; return 0                         ;;
                --update*) UpdateProgram || return 1; return 0          ;;
                --verbose) LOGLEVEL=3                                   ;;
                --loglevel|--log-level) consume_val LOGLEVEL "${value}" i ;;
                *) log error "invalid global option '${arg}'"; return 1 ;;
            esac

            { require_var "${m}" && i=$((i+1)); } || \
                { value=""; continue; }
        fi

        arg="${args[i]:-}"
        require_var "${arg}" || continue
        [[ ( "$((${#args[@]} - i))" -ge 1 && -n "${args[$((i+1))]:-}" ) && \
            "${args[$((i+1))]:-}" != -* ]] && \
                value="${args[$((i+1))]:-}"
        if [[ "${arg}" == -*=* ]]; then
            value="${arg#*=}" arg="${arg%%=*}"
            [[ -n "${value}" ]] || \
                { log error "'${arg}' requires a value"; return 1; }
            i=$((i-1))
        fi
        if [[ "${m}" == edit* && "${arg}" =~ ^(-c|--comment)$ ]]; then
            consume_val comment_string "${value}" i
            # arg="${args[i]:-}"
            continue
        fi
        case "${arg}" in
            -u|--use) consume_val t_content "${value}" i                                ;;
            -j|--journal) consume_val journal_name "${value}" i; select_journal=1       ;;
            -l|--log) consume_val log_name "${value}" i; select_log=1                   ;;
            -t|--template) consume_val template_name "${value}" i; select_template=1    ;;
            *) log error "Invalid argument '${arg}' for '${m}'"; return 1               ;;
        esac
    done

    log debug "loglevel $LOGLEVEL"

    [[ "$#" -ne 0 ]] || { log help_info \
        "not sure? look --help you may find it helpful"; return 1; }

    # ensure everything exists in place
    mkdir -p "${D_JOURNAL_DIR}" "${D_DATA_DIR}" "${D_LOG_DIR}" \
        "${D_SPLS_DIR}" "${D_TEMPLATE_DIR}" "${D_KEY_DIR}"

    # List directory contents with comments
    if { is_flag_enabled "$list_journals" || \
            is_flag_enabled "$list_templates"; } || \
                require_var "${list_something_value}"; then
        is_flag_enabled "$list_journals" && list_something_value="journals"
        is_flag_enabled "$list_templates" && list_something_value="templates"
        ListDirectory "${list_something_value}"; return 0
    fi

    # concatinate given journal/log/template
    if is_flag_enabled "$cat_something"; then
        { require_var "${cat_something_value}" || require_var "${journal_name}" || \
            require_var "${log_name}" || require_var "${template_name}"; } || \
            { log help_info "'cat' but what?" \
                "express --template or --journal after 'cat' or give a value"; return 1; }
        name="${cat_something_value:-${journal_name:-${template_name:-${log_name}}}}"
        f_path="$(DispatchPath guess "${name}")" || \
            { log error "garbage value '${name}'"; return 1; }
        PrettyPrintFile guess "${f_path}" "cat"; return 0
    elif require_var "${cat_something_value}"; then
        if is_flag_enabled "$cat_journal" || \
            are_flags_enabled "${cat_something}" "${select_journal}"; then
            PrettyPrintFile journal "${cat_something_value}" "cat"; return 0
        elif is_flag_enabled "$cat_template" || \
            are_flags_enabled "${cat_something}" "${select_template}"; then
            PrettyPrintFile template "${cat_something_value}" "cat"; return 0
        elif is_flag_enabled "$cat_log" || \
            are_flags_enabled "$cat_something" "$select_log" ; then
            PrettyPrintFile log "${cat_something_value}" "cat"; return 0
        fi
    elif is_flag_enabled "$cat_journal"; then
        require_var "${journal_name}" || \
            { log usage "to cat journal: use --journal to specify journal name"; return 1; }
        PrettyPrintFile journal "${journal_name}" "cat"; return 0
    elif is_flag_enabled "$cat_log"; then
        require_var "${log_name}" || \
            { log usage "to cat log: use --log to specify log name"; return 1; }
        PrettyPrintFile log "${log_name}" "cat"; return 0
    elif is_flag_enabled "$cat_template"; then
        require_var "${template_name}" || \
            { log usage "to cat log: use --template to specify template name"; return 1; }
        PrettyPrintFile template "${template_name}" "cat"; return 0
    fi

    # show given journal/log/template
    if is_flag_enabled "$show_something"; then
        { require_var "${show_something_value}" || require_var "${journal_name}" || \
            require_var "${log_name}" || require_var "${template_name}"; } || \
            { log help_info "'show' but what?" \
                "express --template or --journal after 'show' or give a value"; return 1; }
        name="${show_something_value:-${journal_name:-${template_name:-${log_name}}}}"
        PrettyPrintFile guess "${name}" "pager"; return 0
    elif require_var "${show_something_value}"; then
        if is_flag_enabled "$show_journal" || \
            are_flags_enabled "$show_something" "$select_journal"; then
            PrettyPrintFile journal "${show_something_value}" "pager"; return 0
        elif is_flag_enabled "$show_template" || \
            are_flags_enabled "$show_something" "$select_template"; then
            PrettyPrintFile template "${show_something_value}" "pager"; return 0
        elif is_flag_enabled "$show_log" || \
            are_flags_enabled "$show_something" "$select_log"; then
            PrettyPrintFile log "${show_something_value}" "pager"; return 0
        fi
    elif is_flag_enabled "$show_journal"; then
        require_var "${journal_name}" || \
            { log usage "to show journal: use --journal to specify journal name"; return 1; }
        PrettyPrintFile journal "${journal_name}" "pager"; return 0
    elif is_flag_enabled "$show_log" ; then
        require_var "${log_name}" || \
            { log usage "to show log: use --log to specify log name"; return 1; }
        PrettyPrintFile log "${log_name}" "pager"; return 0
    elif is_flag_enabled "$show_template" ; then
        require_var "${template_name}" || \
            { log usage "to show template: use --template to specify template name"; return 1; }
        PrettyPrintFile template "${template_name}" "pager"; return 0
    fi

    # edit given journal/log/template
    if is_flag_enabled "$edit_something"; then
        { require_var "${edit_something_value}" || require_var "${journal_name}" || \
            require_var "${log_name}"; } || \
            { log help_info "'edit' but what?" \
                "express --template or --journal after 'edit' or give a value"; return 1; }
        name="${edit_something_value:-${journal_name:-${log_name}}}"
        EditJournal guess "${name}" "${template_name}" \
            "${t_content}" "${comment_string}"; return 0
    elif require_var "${edit_something_value}"; then
        if is_flag_enabled "$edit_journal" || \
            are_flags_enabled "$edit_something" "$select_journal"; then
            EditJournal journal "${edit_something_value}" "${template_name}" \
                "${t_content}" "${comment_string}"; return 0
        elif is_flag_enabled "$edit_template" || \
            are_flags_enabled "$edit_something" "$select_template"; then
            EditTemplate "${edit_something_value}" "${t_content}" "${comment_string}"; return 0
        elif is_flag_enabled "$edit_log" || \
            are_flags_enabled "$edit_something" "$select_log"; then
            EditJournal log "${edit_something_value}" "${template_name}" \
                "${t_content}" "${comment_string}"; return 0
        fi
    elif is_flag_enabled "$edit_journal"; then
        require_var "${journal_name}" || \
            { log usage "to edit journal: use --journal to specify journal name"; }
        EditJournal journal "${journal_name}" "${template_name}" \
            "${t_content}" "${comment_string}"; return 0
    elif is_flag_enabled "$edit_log"; then
        require_var "${log_name}" || \
            { log usage "to edit log: use --log to specify log name"; return 1; }
        EditJournal log "${log_name}" "${template_name}" \
            "${t_content}" "${comment_string}"; return 0
    elif is_flag_enabled "$edit_template"; then
        require_var "${template_name}" || \
            { log usage "to edit template: use --template to specify template name"; return 1; }
        EditTemplate "${template_name}" "${t_content}" "${comment_string}"; return 0
    fi
}

main "${@}"

