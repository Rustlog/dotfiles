#!/usr/bin/env bash

builtin set -euo pipefail

# -----------------------------------------------------------------------------
# @title    mountssh
# @desc     A portable SSHFS mounting utility script with network checks,
#           timeout auto-unmounting, and remote config editing via terminal.
# @author   Rustlog
# @version  1.0
# @license  MIT
# @repo     https://github.com/Rustlog/Dotfiles
# -----------------------------------------------------------------------------

# Operation flags
ENABLE_DEBUG=0    # Override debug config with --debug flag or manual toggle

builtin readonly PROFILE_DIRECTORY="${HOME}/.custom/${0##*/}"

### Default Config Template (Do not touch it) ###
declare -A CONFIG=(
    # Remote SSH username
    [USER]=""
    # Remote host (IP or FQDN (Fully Qualified Domain Name))
    [HOST]=""
    # Remote path to mount
    [REMOTE_MOUNT_POINT]=""
    # Local mount-point
    [LOCAL_MOUNT_POINT]=""
    # SSH Port (Usually 22)
    [PORT]=""
    # Path to SSH private key
    [PRIVATE_KEY]=""
    # Extra SSHFS options
    [SSH_OPTIONS]=""
    # Enable script debugging
    [DEBUG]=0
    # Enable colors
    [COLORS]=1
    # Ping timeout (sec) (Network check)
    [PING_TIMEOUT]=1
    # Auto un-mount after N seconds (0 = disable)
    [MOUNT_TIMEOUT]=0
)

### Unified logging logging function
# Supported log types: info | warn | error | debug
function log() {
    local type_="${1}"
    shift
    local color
    case "$type_" in
        info) color="${GREEN}" ;;
        cmd_info) color="${CMD_INFO}" ;;
        warn) color="${ORANGE}" ;;
        error) color="${RED}" ;;
        cmd_error) color="${CMD_INFO}" ;;
        debug)
            [[ ${CONFIG["DEBUG"]} -eq 1 || $ENABLE_DEBUG -eq 1 ]] || return
            color="${DEBUG_GRAY}"
            ;;
    esac
    printf "  [%b%b%b]: %b\n" "${color}" "${type_}" "${NC}" "$*"
}

### Show usage
function Usage() {
    local -i colors="${1}"
    if [[ $colors -eq 1 ]]; then
        local RED="\033[0;31m" GREEN="\033[0;32m" \
            YELLOW="\033[38;2;212;184;142m" BLUE="\033[38;2;126;117;255m" \
            LIGHT_BLUE="\033[38;2;146;165;200m" BOLD="\033[1m" NC="\033[0m"
    else
        local RED="" GREEN="" YELLOW="" BLUE="" \
            LIGHT_BLUE="" BOLD="" NC=""
    fi

    local scriptName="${YELLOW}${0##*/}${NC}"

    printf "%b\n" \
        "${BOLD}${LIGHT_BLUE}${scriptName}${NC}${BOLD}${LIGHT_BLUE} - Portable SSHFS mount and SSH utility with network checks and auto unmount${NC}" \
        "" \
        "${BOLD}Usage:${NC}" \
        "  ${scriptName} [options] [profile]${NC}" \
        "" \
        "${BOLD}Filesystem Operations:${NC}"
    printf "    ${GREEN}%-4s ${GREEN}%-32s${NC} %s\n" \
        "-m"   "--mount|mount"        "Mount the SSHFS mount-point" \
        "-u"   "--umount|umount"      "Unmount the SSHFS mount-point" \
        ""     "--ssh|ssh"            "Directly SSH into remote"

    printf "%b\n" "\n${BOLD}Profile Management:${NC}\n"
    printf "    ${GREEN}%-4s %-32s${NC} %b\n" \
        "-p"   "--profile|profile"                  "Specify the profile name" \
        "-e"   "--edit|edit"                        "Edit the SSHFS configuration file" \
        "-l"   "--list-profiles|list-profiles"      "Show available profiles in ${BLUE}$(EvalVars "${PROFILE_DIRECTORY}")${NC}" \
        ""     "--remove|remove"                    "Remove the profile" \
        ""     "--backup|backup"                    "Backup the original profile with *.bak suffix" \
        ""     "--restore|restore"                  "Restore the backup only if the original profile does not exist" \
        ""     "--cat|cat"                          "Concatenate the config file" \
        ""     "--show-profile|show-profile"        "Display and load a specific profile by name" \
        ""     "--show|show"                        "loaded and show default or specified profile"

    printf "%b\n" "\n${BOLD}Other Options:${NC}\n"
    printf "    ${GREEN}%-4s ${GREEN}%-32s${NC} %s\n" \
        "-c"   "--config|config"            "Specify the full path to config file" \
        "-f"   "--force|force"              "Do not confirm" \
        "-h"   "--help|help"                "Show this help message and exit" \
        "-d"   "--debug|debug"              "Enable debug output" \
        ""     "--no-color"                 "Disable color output" \
        ""     "--version"                  "Show script version"

    printf '\n'
    printf "%b\n" \
        "${BOLD}Description:${NC}" \
        "  This script mounts remote filesystems over SSHFS with automatic network checks," \
        "  optional auto-unmount after a timeout, and supports editing configuration interactively." \
        "  This script also supports direct SSH into remote" \
        "" \
        "${BOLD}Examples:${NC}" \
        "   Mount from profile, remount in subsequent runs" \
        "    $ ${scriptName} <profile>${NC}" \
        "   Opens the profile in your text EDITOR for modification." \
        "    $ ${scriptName} edit <profile>${NC}" \
        "   Mounts the SSHFS filesystem from profile." \
        "    $ ${scriptName} mount <profile>${NC}" \
        "   Unmounts the mounted SSHFS filesystem from profile." \
        "    $ ${scriptName} u(n)mount <profile>${NC}" \
        "   SSH into remote from profile." \
        "    $ ${scriptName} ssh <profile>${NC}" \
        ""
}

### Immediately exit when FATAL is called
function FATAL() {
    local msg="${1}"
    local -i exit_code=${2:-1}
    [[ $exit_code -gt 0 ]] && {
        printf "[fatal]: %b\n" "$msg"
        exit $exit_code
    }
}

### Installs a package using the system's package manager
# Detects pacman, apt, dnf, or yum
function InstallTool() {
    local -A pkg_map=(
        [fuser]="psmisc"
        [fusermount]="fuse3"
        [sshfs]="sshfs"
        [findmnt]="util-linux"
        [lsof]="lsof"
        [tree]="tree"
    )
    local -a pkgs=()
    for bin in "${@}"; do
        local pkg="${pkg_map[$bin]:-$bin}"
        pkgs+=("$pkg")
    done

    if command -v apt &> /dev/null; then
        sudo apt install -y "${pkgs[@]}"
    elif command -v pacman &> /dev/null; then
        sudo pacman --needed -S "${pkgs[@]}"
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y "${pkgs[@]}"
    else
        log error "unsupported package manager. Please install tools manually: ${pkgs[*]}"
        FATAL "exit reason: could not install a tool" 1
        return 1
    fi
}

### Check required tools as dependencies
function CheckDependencies() {
    local -a deps=( sshfs ssh fuser tree fusermount findmnt lsof )
    local -a missing=()
    local yesno

    for cmd in "${deps[@]}"; do
        command -v "$cmd" &> /dev/null || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log error "${missing[*]} not found; install it first."
        printf "%s: " "Install ${missing[*]} (y|n)"; read -r -n 1 yesno
        if [[ $yesno =~ ^(y|Y)$ ]]; then
            InstallTool "${missing[@]}"
        else
            FATAL "exit reason: install abort" 1
        fi
    fi
}

### Auto-detects and sets a TUI text editor (Neovim > Vim > Nano) for config editing
# Falls back to installing vim if none found
function SetTextEditor() {
    local -a Editors=( nvim vim micro nano )
    local found=""
    command -v "${EDITOR}" &> /dev/null && found="${EDITOR}"
    for editor in "${Editors[@]}"; do
        if command -v nvim 1> /dev/null 2>&1; then
            [[ -z ${found} ]] && found="${editor}"
            break
        fi
    done
    if [[ -z $found ]]; then
        log warn "no text editor found on your system"
        log info "Installing vim"
        InstallTool "vim"
    fi
    EDITOR=${found:-"vim"}
}

### Set ASCII colors
function SetColors() {
    # ANSI escape sequences for RGB-based color output (eye candy logging in terminal)
    local -i colors="$1"
    if [[ $colors -eq 0 || ${CONFIG["COLORS"]} -eq 0 ]]; then
        RED='' GREEN='' BLUE='' DEBUG_GRAY='' LITTLE_BLUE=''
        YELLOW='' SKIN_COL='' GRAY='' ORANGE='' NC=''
        return 0
    fi
    export RED="\033[38;2;255;75;75m"
    export GREEN="\033[38;2;138;230;81m"
    export BLUE="\033[38;2;110;147;235m"
    export DEBUG_GRAY="\033[38;2;200;200;200m"
    export LITTLE_BLUE="\033[38;2;126;117;255m"
    export CMD_INFO="\033[38;2;166;54;244m"
    export YELLOW="\033[38;2;226;220;120m"
    export SKIN_COL="\033[38;2;170;170;127m"
    export GRAY="\033[38;2;125;125;125m"
    export ORANGE="\033[38;2;255;170;10m"
    export NC="\033[0m"
}

### Special message for termux users
function TermuxUser() {
    ### Helping Messages for Termux user
    log info "The termux default user home directory '${LITTLE_BLUE}${1:-""}/data/data/com.termux/files/home${NC}'"
    log info "Phone's internal stroage filesystem '${LITTLE_BLUE}${1:-""}/storage/emulated/0/${NC}'"
}

### Change user's exposed paths, username etc with bash-style variables
function EvalVars() {
    sed -e "s@${HOME:-""}@~@g" \
        -e "s@${USER:-""}@\$USER@g" <(printf '%s\n' "${1}")
}

### Color blue the given path
function ColorPath() {
    printf '%b\n' "${LITTLE_BLUE//\\/\\\\}$(EvalVars "${1}")${NC//\\/\\\\}"
}

### Displays an ASCII-style script banner
function DrawBanner() {
    printf "%b\n" "${YELLOW}==========================" \
                           "║ SSHFS Mount Utility    ║" \
                           "==========================${NC}"
}

### Nicely formats and prints current loaded config to stdout
# Triggered by --show or DEBUG=1
function ShowLoadedProfile() {
    local profile="${1}"
    local -i should_show_profile_=${2}
    local -a LogVar=("printf" "# ${GRAY}%b${NC}\n# ${ORANGE}%-40b${NC} = %b\n\n")
    local -a PrettyLog=("printf" "%b\n")

    if [[ ${CONFIG["DEBUG"]} -eq 1 || $should_show_profile_ -eq 1 ]]; then
        "${PrettyLog[@]}" \
            "#================#" \
            "# Profile: $(ColorPath "${profile}") #" \
            "#=============#==========================#"
        "${LogVar[@]}" \
            "### SSH Username on the remote device" \
            "USER" "\"${CONFIG["USER"]}\"" \
            "### Ip address or FQDN (Fully Qualified Domain Name) of the remote" \
            "HOST" "\"${CONFIG["HOST"]}\"" \
            "### SSH Port to use for connection" \
            "PORT" "${BLUE}${CONFIG["PORT"]}${NC}" \
            "### Remote path to mount" \
            "REMOTE_MOUNT_POINT" "\"${CONFIG["REMOTE_MOUNT_POINT"]}\"" \
            "### Local directory or mount the remote path to" \
            "LOCAL_MOUNT_POINT" "\"${CONFIG["LOCAL_MOUNT_POINT"]}\"" \
            "### Private key for SSH authentication" \
            "PRIVATE_KEY" "\"${CONFIG["PRIVATE_KEY"]}\"" \
            "### Additional SSH options (e.g., -oreconnect)" \
            "SSH_OPTIONS" "\"${CONFIG["SSH_OPTIONS"]}"\" \
            "### Enable bash script debugging (yes or no)" \
            "DEBUG" "${BLUE}${CONFIG["DEBUG"]}${NC}" \
            "### Timeout in seconds to wait for the remote host to respond (Network check)" \
            "PING_TIMEOUT" "${BLUE}${CONFIG["PING_TIMEOUT"]}${NC}" \
            "### Automatically unmount after this many seconds (0 to disable)" \
            "MOUNT_TIMEOUT" "${BLUE}${CONFIG["MOUNT_TIMEOUT"]}${NC}"
    fi
}

### Writes CONFIG associative array values into a temporary bash-style config file
# Used for persistence across script runs
function WriteConfigTemplate() {
    local file_name="${1}"
    local -i force=${2}
    local msg_in_profile=""
    local -i doesnotExist=0

    if [[ "${file_name}" == "${default_config_profile}" ]]; then
        log info "default config in use." && printf '\n'
        msg_in_profile="Default profile: $(EvalVars "${file_name}")"
    else
        msg_in_profile="Profile: $(EvalVars "${file_name}")"
    fi

    if [[ ! -f "${file_name}" ]]; then
        doesnotExist=1
        if [[ $force -eq 0 ]]; then
            printf "'%b': %s" "$(ColorPath "${file_name}")" "Create new profile (y|n): "
            read -r -n 1 key; printf '\n'
            if ! [[ "${key}" =~ ^(y|Y)$ ]]; then
                log warn "write operation cacelled for '$(ColorPath "${file_name}")'"
                return 1
            fi
        fi
    fi

cat > "${file_name}" << EOF
#!/usr/bin/env bash

#@#==( ${msg_in_profile} )==#@#

### Configuration File for SSHFS Mounting and SSH into remote

### SSH Username on the remote device
USER="${CONFIG["USER"]:-"root"}"

### Ip address or FQDN (Fully Qualified Domain Name) of the remote
HOST="${CONFIG["HOST"]:-"0.0.0.0"}"

### SSH Port to use for connection
PORT=${CONFIG["PORT"]:-22}

### Remote path to mount
REMOTE_MOUNT_POINT="${CONFIG["REMOTE_MOUNT_POINT"]:-"/"}"

### Local directory or mount the remote path to
LOCAL_MOUNT_POINT="${CONFIG["LOCAL_MOUNT_POINT"]:-"/tmp/mount_${file_name##*/}"}"

### Private key for SSH authentication
PRIVATE_KEY="${CONFIG["PRIVATE_KEY"]}"

### Additional SSH options (e.g., -oreconnect)
SSH_OPTIONS="${CONFIG["SSH_OPTIONS"]}"

### Enable bash script debugging (yes or no)
DEBUG=${CONFIG["DEBUG"]}

### Enable colors
COLORS=1

### Timeout in seconds to wait for the remote host to respond (Network check)
PING_TIMEOUT=${CONFIG["PING_TIMEOUT"]}

### Automatically unmount after this many seconds (0 to disable)
MOUNT_TIMEOUT=${CONFIG["MOUNT_TIMEOUT"]}

# vim:filetype=bash

EOF
    [[ $doesnotExist -eq 1 ]] && log info "new configuration file created: $(ColorPath "${file_name}")" || return 0
}

### Compare invalid hosts with given host
function ValidateHost() {
    local -a invalids=("0.0.0.0" "")
    for i in "${invalids[@]}"; do
        if [[ "${CONFIG["HOST"]}" == "${i}" ]]; then
            log error "Invalid SSH host: '${CONFIG["HOST"]}'. Please edit your config."
            FATAL "exit reason: invalid host error" 1
        fi
    done
}

### Load config context to current script
function LoadConfigFile() {
    local profile="${1}"
    local -i should_show_profile_=${2}

    if [[ $profile_loaded -eq 1 ]]; then
        ShowLoadedProfile "${profile}" "$should_show_profile_"
        return 0
    fi

    [[ -f "${profile}" ]] || FATAL "exit reason: '${profile}' not a regular file" 1
    # shellcheck source=/dev/null
    source "${profile}" || FATAL "exit reason: couldn't source '$(EvalVars "${profile}")'" 1

    local -a config_vars=(
        USER HOST PORT PRIVATE_KEY
        REMOTE_MOUNT_POINT LOCAL_MOUNT_POINT
        SSH_OPTIONS DEBUG COLORS
        PING_TIMEOUT MOUNT_TIMEOUT
    )
    IFS=$' '
    for key in "${config_vars[@]}"; do
        CONFIG[$key]="${!key}"
        unset "$key"
    done
    [[ -z "${CONFIG["USER"]}" ]] && {
        CONFIG["USER"]="root"
        log error "No SSH username given in the config. Assuming its root now."
    }
    [[ -z "${CONFIG["HOST"]}" ]] && {
        log error "No SSH hostname given Cannot load the config '$(ColorPath "${profile}")'. Edit the config"
    }
    [[ -z "${CONFIG["REMOTE_MOUNT_POINT"]}" ]] && {
        CONFIG["REMOTE_MOUNT_POINT"]="/"
        log error "No remote mount-point given in the config. Assuming its ${LITTLE_BLUE}/${NC}"
    }
    [[ -z "${CONFIG["LOCAL_MOUNT_POINT"]}" ]] && {
        CONFIG["LOCAL_MOUNT_POINT"]="/tmp/mount_${profile##*/}"
    }

    SetColors $should_use_colors

    profile_loaded=1

    ShowLoadedProfile "${profile}" "$should_show_profile_"
    return 0
}

### Set flags for sshfs command
function SetUpSSH_CMD() {
    local -n array_name_ref=${1}
    # Fill array_name_ref array with sshfs flags and parameters
    [[ -n ${CONFIG["PRIVATE_KEY"]} ]] && [[ -r "${CONFIG["PRIVATE_KEY"]}" ]] && {
        array_name_ref+=("-o" "IdentitiesOnly=yes" "-o" "IdentityFile=${CONFIG["PRIVATE_KEY"]}")
    }
    [[ -n "${CONFIG["SSH_OPTIONS"]}" ]] && array_name_ref+=("-o" "${CONFIG["SSH_OPTIONS"]}")
    [[ -z ${CONFIG["PORT"]} && "${CONFIG["USER"]}" == u0_a* ]] && CONFIG["PORT"]=8022
    [[ -z ${CONFIG["PORT"]} ]] && CONFIG["PORT"]=22
    [[ -n ${CONFIG["PORT"]} ]] && array_name_ref+=("-o" "ssh_command=ssh -p ${CONFIG["PORT"]}")
    array_name_ref+=("${CONFIG["USER"]:="root"}@${CONFIG["HOST"]}:${CONFIG["REMOTE_MOUNT_POINT"]:="/"}")
    array_name_ref+=("${CONFIG["LOCAL_MOUNT_POINT"]:="/tmp/DEFAULT_MOUNT"}")
}

### Prompts user interactively to fill in CONFIG values
# Uses defaults when input is empty
function GetConfig() {
    # Inner function to prompt user, with default & message
    local -i guess=0

    get_useInput() {
        local -n ref=${1}
        local prompt="${2}"
        local default="${3}"
        local default_msg="${4}"

        printf "%b%s%b" "${LITTLE_BLUE}" "${prompt}" "${NC}"
        [[ -n "${default}" ]] && printf " [%s]" "${default}"
        printf ": "

        read -r input

        if [[ -z "${input}" && -n "${default}" ]]; then
            ref="${default}"
            [[ -n "${default_msg}" ]] && printf '%s\n' "${default_msg}"
        else
            # shellcheck disable=SC2034
            ref="${input}"
        fi
    }

    get_useInput CONFIG["USER"] "User" "root" "Assuming you are root."

    get_useInput CONFIG["HOST"] "Host (IP or FQDN)" "" ""
    if [[ -z ${CONFIG["HOST"]} ]]; then
        printf '\n' && log error "Host is required, exiting."
        return 1
    fi

    [[ "${CONFIG["USER"]}" == u0_a* ]] && guess=8022 || guess=22
    get_useInput CONFIG["PORT"] "Port" "${guess}" "Assuming port ${guess}"
    if [[ -z ${CONFIG["PORT"]} ]]; then
        printf '\n' && log error "Port is required, exiting."
        return 1
    fi
    get_useInput CONFIG["REMOTE_MOUNT_POINT"] "Remote mount-point" "/" "Default ${BLUE}/${NC}"
    get_useInput CONFIG["LOCAL_MOUNT_POINT"] "Local mount-point" \
        "/tmp/mount_${config_profile##*/}" "default '${BLUE}/tmp/mount_${config_profile##*/}${NC}'"
    get_useInput CONFIG["MOUNT_TIMEOUT"] "Mount timeout (seconds)" "0" "Default 0"
    get_useInput CONFIG["SSH_OPTIONS"] "SSH options" "" ""
    get_useInput CONFIG["PRIVATE_KEY"] "Private key" "" ""

    unset -f get_useInput
}

### Concatenate config using bat and fallback cat command
function Cat_config() {
    local file="${1}"
    local should_color="always"
    if command -v bat &> /dev/null; then
        [[ $2 -eq 1 ]] || should_color="never"
        bat --paging=never --color=$should_color --decorations=never --language=bash "${file}"
    else
        cat "${file}"
    fi
}

### Opens config file using $EDITOR
# If config file doesn’t exist or is empty, creates it with defaults
function EditConfig() {
    SetTextEditor
    local profile="${1}"
    local -i force_profile_creation=${2} col=${3}
    local diff_output="" should_color="always"
    local yes_no=""

    if [[ ! -s "${profile}" ]]; then
        if ! WriteConfigTemplate "${profile}" "$force_profile_creation"; then
            log error "cannot write '$(ColorPath "${profile}")'"
            FATAL "exit reason: write aborted" 1
        fi
    fi

    local temp_edit="${profile}.tmp_edit"

    [[ $col -eq 1 ]] || should_color="never"

    if [[ -z "${profile}" ]]; then
        log error "no profile was given to edit"
        FATAL "exit reason: profile not given" 1
    fi

    log info "edit $(ColorPath "${temp_edit%.*}")"

    cp "${profile}" "${temp_edit}"
    if ${EDITOR:-"vim"} "${temp_edit}"; then
        diff_output="$(diff --color=$should_color "${profile}" "${temp_edit}" || true)"
    fi

    if [[ "${#diff_output}" -eq 0 ]]; then
        log info "edit finished, exiting..."
        rm -f "${temp_edit}"
        return 0
    fi

    log info "your changes"
    printf '%s\n' "${diff_output}"

    printf '%s' "accept changes? (y|n): "; read -r -n 1 yes_no
    if [[ "${yes_no}" =~ ^(y|Y)$ || "${yes_no}" == "" ]]; then
        if mv "${temp_edit}" "${profile}"; then
            log info "new changes saved"
        else
            log info "failed to save new changes"
        fi
    else
        log info "discarded new changes"
        rm -f "${temp_edit}"
        return 0
    fi

    printf '%s' "show config file? (y|n): " ; read -r -n 1 yes_no
    if [[ "${yes_no}" =~ ^(y|Y)$ ]]; then
        Cat_config "${profile}" $col
    fi

    rm -f "${temp_edit}"
    log info "edit finished, exiting..."
}

function removeDir() {
    local dir="${1}"

    log info "removing '${BLUE}${dir}${NC}'"
    if rmdir "${dir}" &> /dev/null; then
        log cmd_info "$(${colored_cmd} <<< "rmdir '${dir}'")"
        log info "cleaned: ${BLUE}${dir}${NC}" && printf '\n'
    else
        log cmd_error "$(${colored_cmd} <<< "rmdir '${dir}'")"
        log error "failed to Clean: ${BLUE}${dir}${NC}" && printf '\n'
    fi
}

### Checks mount-point, attempt unmount if mount-point exists
function AttemptUnMount() {
    local -r mountpoint="${1}"

    if [[ ! -d "${mountpoint}" ]]; then
        return 2
    fi

    # If it's not a mount-point, but directory still exist
    if [[ -d "${mountpoint}" ]] && ! mountpoint -q "${mountpoint}"; then
        removeDir "${mountpoint}"
        return 0
    fi

    log info "'${mountpoint}' is already mounted, unmounting"

    # Clean lazy unmount
    log info "attempting to Unmount '${mountpoint}'"
    log cmd_info "$(${colored_cmd} <<< "fusermount -uz '${mountpoint}'")"
    if timeout 2 fusermount -uqz "${mountpoint}" &> /dev/null; then
        log info "successfully lazy unmount via fusermount: '${BLUE}${mountpoint}${NC}'" && printf '\n'
        removeDir "${mountpoint}"
        return 0
    else
        log error "mount failed, attempting umount" && printf '\n'

        log info "attempting again to Unmount '${mountpoint}'"
        log cmd_info "$(${colored_cmd} <<< "umount --lazy '${mountpoint}' &> /dev/null")"
        if umount --lazy "${mountpoint}" &> /dev/null; then
            log info "successfully lazy unmount via umount: '${BLUE}${mountpoint}${NC}'" && printf '\n'
        else
            log warn "mount still stuck, likely a zombie" && printf '\n'
            removeDir "${mountpoint}"
            return 1
        fi
        removeDir "${mountpoint}"
        return 0
    fi

    log warn "fusermount -uz '${BLUE}${mountpoint}${NC}' failed. Trying fallback methods"

    # Check if anything holding the mount-point
    if command -v "lsof" &> /dev/null; then
        log info "files still open:"
        lsof +D "${mountpoint}"
    elif command -v "fuser" &> /dev/null; then
        log info "open files:"
        fuser -vm "${mountpoint}"
    fi

    # SSHFS tied to this mount
    if timeout 2 findmnt -n -T "${mountpoint}" | grep -q "${mountpoint}"; then
        log warn "${BLUE}${mountpoint}${NC} is still mounted"
    fi
    # Try lazy unmount again
    if timeout 2 fusermount -uz "${mountpoint}" &> /dev/null; then
        log info "successfully unmount: ${BLUE}${mountpoint}${NC}"
        removeDir "${mountpoint}"
        return 0
    fi
    # Final check in /proc/mounts
    if grep -q "${mountpoint}" /proc/mounts; then
        log warn "mount still listed in /proc/mounts — might be a zombie or stale mount"
        log info "final attempt with lazy unmount"
        if umount -l "${mountpoint}" &>/dev/null; then
            removeDir "${mountpoint}"
            return 0
        else
            removeDir "${mountpoint}"
            return 1
        fi
    fi
}

### Check Reachability of the host using ping command
function HostReachable() {
    local host="${1}"
    if ! ping -c 1 -W "${CONFIG["PING_TIMEOUT"]}" "${host}" &> /dev/null; then
        log error "'${LITTLE_BLUE}${host}${NC}' not reachable, check the connection."
        return 1
    fi
}

### Create local mount-point (directory)
function CreateLocalMount() {
    local dir="${1}"; shift

    mkdir -p "${dir}" &> /dev/null || {
        log error "cannot create '${LITTLE_BLUE}${dir}${NC}'"
        FATAL "exit reason: write error" 1
    }
}

### Attempt mounts
function AttemptMount() {
    local -a cmd=("${@}")
    for i in {1..3}; do
        [[ $i -ge 2 ]] && log info "attemting mount $i"
        log info "mounting remote: '${CONFIG["HOST"]}' from profile $(ColorPath "${config_profile}")"
        log cmd_info "$(${colored_cmd} <<< "timeout 4s sshfs ${cmd[*]}")"
        timeout 4s sshfs "${cmd[@]}" && return 0
        sleep $((i*2))
    done
    return 1
}

### Main logic for mounting
function MountSSHFS_() {
    local -a sshfs_cmd=("${@}")
    local color=""

    [[ $should_use_colors -eq 1 ]] && color="always" || color="never"

    # Create local mount-point
    if [[ ! -d "${CONFIG[LOCAL_MOUNT_POINT]}" ]]; then
        CreateLocalMount "${CONFIG[LOCAL_MOUNT_POINT]}"
    fi

    # Mount the remote or local device file system as a fuse.sshfs device using OpenSSH protocol
    if AttemptMount "${sshfs_cmd[@]}"; then
        log info \
            "mounted $(mount | grep --color=$color -E "${CONFIG["USER"]}|${CONFIG["HOST"]}|${CONFIG["LOCAL_MOUNT_POINT"]}")" && printf '\n'

        # Auto-unmount
        if [[ ${CONFIG["MOUNT_TIMEOUT"]} -gt 0 ]]; then
            log info "auto-unmount set: ${CONFIG["MOUNT_TIMEOUT"]}"
            log cmd_info "$(${colored_cmd} <<< "(sleep ${CONFIG["MOUNT_TIMEOUT"]} && timeout 4s --signal KILL fusermount -u ${CONFIG["LOCAL_MOUNT_POINT"]}) &")" && printf '\n'
            (sleep ${CONFIG["MOUNT_TIMEOUT"]} && timeout 4s --signal KILL fusermount -u "${CONFIG["LOCAL_MOUNT_POINT"]}") & disown
        fi
        if [[ "${CONFIG["USER"]}" == u0_a* ]]; then
            # Special message for Termux users
            TermuxUser "${CONFIG["LOCAL_MOUNT_POINT"]}" && printf '\n'
        fi
    else
        log error "failed to mount SSHFS remote:"
        log cmd_error "$(${colored_cmd} <<< "${sshfs_cmd[*]}")" && printf '\n'
        AttemptUnMount "${CONFIG["LOCAL_MOUNT_POINT"]}"
    fi
}

### If mount directory is mounted, try unmounting
function MountCheck() {
    local -i should_unmount_=${1}
    local -i should_ssh_=${2}
    # Handles forced unmounting if its already mounted or --unmount is used
    AttemptUnMount "${CONFIG["LOCAL_MOUNT_POINT"]}";
    if [[ $? -eq 1 ]]; then
        log warn "failed to unmount ${BLUE}${CONFIG["LOCAL_MOUNT_POINT"]}${NC}"
        FATAL "exit reason: unmount failure" 1
    fi
}

### Find profile in a known directory
function FindProfile() {
    local requested_profile="${1}"
    # shellcheck disable=SC2034
    local -n ref_var=${2}

    local profile="" found_profile=""
    for profile in "${profile_dir}"/*; do
        found_profile="${profile##*/}"
        if [[ "${found_profile}" == "${requested_profile}".bak* ]]; then
            ref_var="${found_profile}"
            return 0
        elif [[ "${found_profile}" == "${requested_profile}" ]]; then
            ref_var="${found_profile}"
            return 0
        elif [[ "${requested_profile}" == "default" ]]; then
            # shellcheck disable=SC2034
            ref_var="default"
            return 0
        fi
    done
    return 1
}

### Parses script arguments like --edit, --show, --unmount, etc.
# Sets flags for conditional execution later
# Main logic of the script
function main() {
    local -a ARGS_ARR=("${@}")
    local -a sshfs_cmd=()

    # On-off Flags
    local -i should_mount_=0 should_ssh_=0 should_unmount_=0
    local -i should_edit_profile=0 should_ls_profile_dir=0
    local -i should_show_profile_=0 should_cat_profile_=0
    local -i force=0
    local -i show_usage=0
    local -i remove_profile=0 backup_profile=0 restore_profile_from_bak=0

    # global vars
    local -g profile_loaded=0 should_use_colors=1
    local -g default_config_profile="${PROFILE_DIRECTORY}/default"
    local -g profile_dir="${PROFILE_DIRECTORY}"
    local -g colored_cmd=""

    # String variables for profile
    local config_profile="${default_config_profile}" backup_config_profile=""
    local requested_profile_base=""

    local arg="" value=""
    for ((i=0;i<${#ARGS_ARR[@]};i++)); do
        arg="${ARGS_ARR[$i]}"
        [[ ${#ARGS_ARR[@]} -gt ${i} ]] && value="${ARGS_ARR[$((i+1))]:-""}"
        if [[ "${arg}" == *=* ]]; then
            value="${arg##*=}"
            arg="${arg%%=*}"
        fi
        case "${arg}" in
            --ssh|ssh)                  should_ssh_=1                         ;;
            -f|-force|force)            force=1                               ;;
            --rm|--rem*|rm|rem*)        remove_profile=1                      ;;
            -m|--mount|mount)           should_mount_=1                       ;;
            -u|--u*mount|u*mount)       should_unmount_=1                     ;;
            -e|edit*)                   should_edit_profile=1                 ;;
            --back*|back*)              backup_profile=1                      ;;
            --res*|res*)                restore_profile_from_bak=1            ;;
            -c=*|--con=*|con=*)         config_profile="${value}"             ;;
            -c|--con*|con*)             config_profile="${value}" i=$((i+1))  ;;
            --show|show)                should_show_profile_=1                ;;
            --cat|cat)                  should_cat_profile_=1                 ;;
            --ssh*mount|ssh*mount)      should_ssh_=1 should_mount_=1         ;;
            --mount*ssh|mount*ssh)      should_ssh_=1 should_mount_=1         ;;
            -l|-*list|-*tree|list|tree) should_ls_profile_dir=1               ;;
            --no-color|--nocolor)       CONFIG["COLORS"]=0 should_use_colors=0  ;;
            -d|-*debug|debug)           CONFIG["DEBUG"]=1 ENABLE_DEBUG=1        ;;
            -h|--help|help)             show_usage=1                          ;;
            -p=*|-*pro*=*|pro*=*)       requested_profile_base="${value}"                                   ;;
            -p*|--pro*|pro*)            requested_profile_base="${value}" i=$((i+1))                        ;;
            --sh*pr*=*|sh*pr*=*)        requested_profile_base="${value}" should_show_profile_=1            ;;
            --sh*pr*|sho*pro*)          requested_profile_base="${value}" should_show_profile_=1 i=$((i+1)) ;;
            *)
                FindProfile "${arg}" "requested_profile_base"
                if [[ "${requested_profile_base}" != "${arg}" ]]; then
                    log error "Invalid argument: $arg"
                    FATAL "exit reason: Invalid argument passed" 1
                fi
                ;;
        esac
    done

    SetColors $should_use_colors

    [[ $show_usage -eq 1 ]] && Usage $should_use_colors && exit 0

    CheckDependencies

    mkdir -p "${profile_dir}"

    if [[ $should_ls_profile_dir -eq 1 ]]; then
        printf '\n' && log info "Available profiles:\n"
        local -a temp_tree_data=("")
        local tree=(tree -C -Fp -sh)
        [[ $should_use_colors -eq 0  ]] && tree=(tree -n -Fp -sh)
        temp_tree_data="$("${tree[@]}" "${profile_dir}")"
        printf '%b\n' "$(ColorPath "${temp_tree_data}")"
        unset temp_tree_data tree
        return 0
    fi

    # Process the requested profile
    if [[ -n "${requested_profile_base}" ]]; then
        local found_base="" config_exists=0
        FindProfile "${requested_profile_base}" found_base
        if [[ -s "${profile_dir}/${found_base}" && -f "${profile_dir}/${found_base}" ]]; then
            config_profile="${profile_dir}/${found_base}"

            if [[ "${found_base}" == *.bak* ]]; then
                config_profile="${profile_dir}/${found_base%.bak*}" # Remove .bak extension
                backup_config_profile="${profile_dir}/${found_base}"
            fi

            config_exists=1
        else
            if ! WriteConfigTemplate "${profile_dir}/${found_base}" $force; then
                log error "failed to write '$(ColorPath "${profile_dir}/${requested_profile_base}")'"
                FATAL "exit reason: write abort" 1
                config_exists=0
            fi
            config_profile="${profile_dir}/${found_base}"

        fi

        if [[ $config_exists -eq 1 && $profile_loaded -eq 0 ]] && [[ -z $backup_config_profile ]]; then
            LoadConfigFile "${config_profile}" "$should_show_profile_"
        fi
        unset found_base config_exists
    fi

    # Restore from backup file
    if [[ $restore_profile_from_bak -eq 1 && -n "${backup_config_profile}" ]]; then
        if [[ -f "${backup_config_profile}" ]]; then
            log info "restore from backup: '${backup_config_profile}'"
            log cmd_info "$(${colored_cmd} <<< "cp '${backup_config_profile}' '${backup_config_profile%.bak*}'")"
            cp "${backup_config_profile}" "${backup_config_profile%.bak*}" && \
                log info "restored '$(ColorPath "${backup_config_profile}")' ==> $(ColorPath "${backup_config_profile%.bak*}")"
        else
            log warn "No such '$(ColorPath "${backup_config_profile}")' backup exists"
        fi
    fi

    # Prompt user to provide config interactively and save the config
    if [[ ! -s "${config_profile}" ]]; then
        [[ -f "${config_profile}" ]] || \
            log warn "new config '$(EvalVars "${config_profile}")'. Edit or Fill the values interactively"
        local userInput
        while true; do
            printf '%s: ' "Edit using EDITOR or Interactive filling? (e|i)"; read -r -n 1 userInput; printf '\n'
            if [[ "${userInput}" =~ ^(e|E)$ ]]; then
                # Get config using text $EDITOR
                EditConfig "${config_profile}" "$force" "$should_use_colors"
                should_edit_profile=0 # prevent next edit trigger
                break
            elif [[ "${userInput}" =~ ^(i|I)$ ]]; then
                # Get config values interactively
                GetConfig || FATAL "exit reason: user interuppted the process" 1
                break
            elif [[ "${userInput}" =~ ^(q|Q)$ ]]; then
                # Just exit the script on Q
                return 1
            else
                log error "only press (\`e\`|\`i\`) or \`q\` to exit"
            fi
        done
        # Write provided values to configuration file
        WriteConfigTemplate "${config_profile}" "$force" || FATAL "exit reason: user aborted profile write" 1
        unset userInput
    fi

    # Load profile and show it
    if [[ $should_show_profile_ -eq 1 ]]; then
        LoadConfigFile "${config_profile}" "$should_show_profile_"
    fi

    # Concatenate profile
    if [[ $should_cat_profile_ -eq 1 ]]; then
        log info "profile: $(ColorPath "${config_profile}")" && printf '\n'
        Cat_config "${config_profile}" $should_use_colors
    fi

    # Backup profile
    if [[ $backup_profile -eq 1 ]]; then
        if [[ -f "${config_profile}" ]]; then
            log info "backup profile: '${config_profile}'"
            log cmd_info "$(${colored_cmd} <<< "cp '${config_profile}' '${config_profile}.bak'")"
            if cp "${config_profile}" "${config_profile}.bak"; then
                log info "backup '$(ColorPath "${config_profile}")' ==> $(ColorPath "${config_profile}").bak" && printf '\n'
            else
                log info "failed to Backup '$(ColorPath "${config_profile}")' ==> $(ColorPath "${config_profile}").bak" && printf '\n'
            fi
        fi
    fi

    # Remove profile
    if [[ $remove_profile -eq 1 ]]; then
        [[ -f "${config_profile}" ]] && rm "${config_profile}" && log info "[!] removed '$(ColorPath "${config_profile}")'"
    fi

    # Edit profile
    if [[ $should_edit_profile -eq 1 ]]; then
        EditConfig "${config_profile}" "$force" "$should_use_colors"
        return 0
    fi

    # Unmount local mount-point
    if [[ $should_unmount_ -eq 1 ]]; then
        AttemptUnMount "${CONFIG["LOCAL_MOUNT_POINT"]}";
        if [[ $? -eq 1 ]]; then
            log warn "failed to unmount ${BLUE}${CONFIG["LOCAL_MOUNT_POINT"]}${NC}"
            FATAL "exit reason: unmount failure" 1
        fi
    fi

    [[ $# -eq 0 || -z "${requested_profile_base}" ]] && return 0 || true

    # Load the config file into current scope of the script
    LoadConfigFile "${config_profile}" $should_show_profile_

    if command -v bat &> /dev/null; then
        local color=""
        [[ $should_use_colors -eq 1 ]] && color="always" || color="never"
        colored_cmd="bat --color=$color --paging=never --decorations=never --language=asm"
        unset color
    else
        true
    fi

    # Before mounting, check if remote is alive and listening
    ValidateHost "${CONFIG["HOST"]}"
    HostReachable "${CONFIG["HOST"]}" || { log error "host '${CONFIG["HOST"]}' down or unreachable"; FATAL "exit reason: host unreachable"; }

    # ASCII Banner
    DrawBanner && printf '\n'

    # SSH and mount
    if [[ $should_ssh_ -eq 1 && $should_mount_ -eq 1 ]]; then
        printf '%s\n' "=====> Mount and SSH into remote <=====" && printf '\n'
        # Mount remote locally
        printf '%s\n' "=====> Mount"
        MountCheck $should_unmount_ $should_ssh_
        SetUpSSH_CMD sshfs_cmd
        MountSSHFS_ "${sshfs_cmd[@]}"

        # SSH into remote
        printf '%s\n' "=====> SSH"
        log info "SSH into '${CONFIG["HOST"]}' from profile $(ColorPath "${config_profile}")"
        log cmd_info "$(${colored_cmd} <<< "ssh -p ${CONFIG["PORT"]} ${CONFIG["USER"]:-"root"}@${CONFIG["HOST"]}")" && printf '\n'
        ssh -p "${CONFIG["PORT"]}" "${CONFIG["USER"]:-"root"}@${CONFIG["HOST"]}"
        return 0
    fi

    # No mount, SSH only
    if [[ $should_ssh_ -eq 1 ]]; then
        printf '%s\n' "=====> SSH only <=====" && printf '\n'
        # SSH into remote
        printf '%s\n' "=====> SSH"
        log info "SSH into '${CONFIG["HOST"]}' from profile $(ColorPath "${config_profile}")"
        log cmd_info "$(${colored_cmd} <<< "ssh -p ${CONFIG["PORT"]} ${CONFIG["USER"]:-"root"}@${CONFIG["HOST"]}")" && printf '\n'
        [[ "${CONFIG["USER"]}" == u0_a* ]] && TermuxUser && printf '\n'
        ssh -p "${CONFIG["PORT"]}" "${CONFIG["USER"]:-"root"}@${CONFIG["HOST"]}"
        return 0
    fi

    ## No SSH, Mount only
    if [[ $should_mount_ -eq 1 ]] || \
        [[ ( -n "${requested_profile_base}" && -n "${config_profile}" ) && \
        ( $should_cat_profile_ -eq 0 && $should_show_profile_ -eq 0 ) ]]; then

        [[ $# -eq 1 ]] && log info "no action specified defaulting to mount" && printf '\n'
        printf '%s\n' "=====> Mount only <=====" && printf '\n'
        # Mount remote locally
        printf '%s\n' "=====> Mount"
        MountCheck $should_unmount_ $should_ssh_
        SetUpSSH_CMD sshfs_cmd
        MountSSHFS_ "${sshfs_cmd[@]}"
        return 0
    fi
}

main "${@}"

