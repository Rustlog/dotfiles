#!/usr/bin/env bash

set -euo pipefail

# Main config file: files and directory mapping
CONFIG_FILE="${HOME}/.config/custom/${0##*/}/config"

# command in use to copy stuff
SYNC_="rsync"

# LOG=0 ERROR=1 INFO=2 DEBUG=3
LOG_LEVEL=1

declare -a COPY_FILES=()
declare -a COPY_DIRS=()

# ASCII colors
GREEN="\033[38;2;42;204;126m"
BLUE="\033[38;2;121;118;214m"
PURPLE="\033[38;2;233;132;64m"
RED="\033[38;2;255;10;10m"
NC="\033[0m"
HL="\033[1m"

function log() {
    local _type="${1}"; shift
    local _color="" _t=""
    local -g info_color="\033[38;2;85;255;126m" \
        warn_color="\033[38;2;255;170;10m" \
        error_color="\033[38;2;244;29;31m" \
        fatal_color="\033[5m\033[38;2;255;0;0m" \
        other_color="\033[38;2;251;255;208m" \
        nc="\033[0m"
    case "${_type}" in
        info) _color="${info_color}" _t=" *" ;;
        warn) _color="${warn_color}" _t=" ^" ;;
        debug) _color="${warn_color}" _t=" @" ;;
        error) _color="${error_color}" _t=" !" ;;
        fatal) _color="${fatal_color}" _t=" #" ;;
        *) _color="${other_color}" _t="" ;;
    esac

    printf "[%b%s%b%s]: %b\n" "${_color}" "${_type}" "${nc}" "${_t}" "${*}"
}

function ColorPath() {
    sed "s@${HOME}@${BLUE//\\/\\\\}~${NC//\\/\\\\}@g" <(printf "%s\n" "${1}")
}

function CreateConfig() {
    local config="$1"
    if cat > "${config}" << EOF
#!/usr/bin/env bash

GIT_DIR="\${HOME}/repos/Dotfiles"

# Your GitHub username
USERNAME=""
# Your GitHub repository
REPO_NAME=""

CONF_DIR="\${HOME}/.config"
C="\${CONF_DIR}"
H="\${HOME}"

### Copy file to file
COPY_FILES=(
    "/etc/vimrc|\${GIT_DIR}/vim/vimrc"
    "/etc/xdg/nvim/init.vim|\${GIT_DIR}/neovim/init.vim"
    "\${H}/.shell_rc|\${GIT_DIR}/shell/SHELL_RC"
    "\${H}/.bashrc|\${GIT_DIR}/shell/bashrc"
    "\${C}/qutebrowser/config.py|\${GIT_DIR}/qutebrowser/config.py"
)

### Copy directory to destination (repo) dir
COPY_DIRS=(
    "\${H}/.bin|\${GIT_DIR}/scripts|1"
    "\${C}/hypr|\${GIT_DIR}/hyprland|1"
    "\${C}/sway|\${GIT_DIR}/sway|1"
    "\${C}/i3|\${GIT_DIR}/i3|1"
    "\${C}/waybar|\${GIT_DIR}/waybar|1"
    "\${C}/wofi|\${GIT_DIR}/wofi|1"
    "\${C}/yazi|\${GIT_DIR}/yazi|1"
    "\${C}/foot|\${GIT_DIR}/foot|1"
    "\${C}/kitty|\${GIT_DIR}/kitty|1"
    "\${C}/alacritty|\${GIT_DIR}/alacritty|1"
)

# vim:filetype=iss

EOF
    then
        log info "Created: '$(ColorPath "${config_file}")'"
    else
        log error "Error creating '$(ColorPath "${config_file}")'"
        return 1
    fi
    return 0
}

function ValidatePaths() {
    local -n indexed_array=${1}
    local valid=0
    for pair in "${indexed_array[@]}"; do
        IFS=$'|' read -r src dest <<< "${pair}"
        if [[ ! -e "${src}" ]]; then
            log error "Invalid file path: $src"
            valid=1
        fi
    done
    return $valid
}

function ValidateDirPaths() {
    local -n indexed_array=${1}
    local valid=0
    for pair in "${indexed_array[@]}"; do
        IFS=$'|' read -r src dest recursive_flag <<< "${pair}"
        if [[ ! -e "${src}" ]]; then
            log error "Invalid directory path: ${src}"
            valid=1
        elif [[ -z $recursive_flag ]]; then
            log error "Recursive flag not given to '$(ColorPath "${pair}")'"
            valid=1
        fi
    done
    return $valid
}

function SourceConfig() {
    local config_file="$1"
    if [[ -s "${config_file}" && -f "${config_file}" ]]; then
        # shellcheck source=/dev/null
        source "${config_file}" || log error "Failed to source '${config_file}'"
    else
        log error "'$(ColorPath "${config_file}")' not found"
        CreateConfig "${config_file}"
        source "${config_file}" || log error "Failed to source '${config_file}'"
    fi
    return 0
}

function EditConfig() {
    local config_file="$1"
    if [[ ! -s "${config_file}" || ! -f "${config_file}" ]]; then
        CreateConfig "${config_file}"
    fi
    ${EDITOR:-vim} "${config_file}"
}

function ShowConfig() {
    local config_file="${CONFIG_FILE}"
    if command -v bat &> /dev/null; then
        bat --paging=never --decorations=never --color=always "${config_file}"
    else
        cat "${config_file}"
    fi
}

function CopyFiles() {
    local src_="$1"
    local dest_="$2"
    local -a cmd_flags=()

    if [[ ! -f "${src_}" ]]; then
        log error "Source '${BLUE}${src_}${NC}' file does not exist"
        return 1
    fi

    if [[ "$SYNC_" != "rsync" ]]; then
        log error "Deletion of orphanes requires 'rsync'. Current: '$SYNC_'"
        return 1
    fi

    mkdir -p "${dest_%/*}"

    if [[ "$SYNC_" == "rsync" ]]; then
        [[ $LOG_LEVEL -ge 2 ]] && cmd_flags+=( "--progress" )
        cmd_flags+=( "--archive" )
    elif [[ "$SYNC_" == "cp" ]]; then
        [[ $LOG_LEVEL -ge 2 ]] && cmd_flags+=( "--verbose" )
        cmd_flags+=( "--archive" )
        cmd_flags+=( "--recursive" )
    fi

    if $SYNC_ "${cmd_flags[@]}" "${src_}" "${dest_}"; then
        log info "Copied '${GREEN}$(ColorPath "${src_}")${NC}' ${PURPLE}--->${NC} '${BLUE}$(ColorPath "${dest_}")${NC}'"
    else
        log error "Copy Failed: ${src_} --> ${dest_}"
    fi
}

function CopyDirs() {
    local src_="$1"
    local dest_="$2"
    local -i delete_flag=$3
    local -a cmd_flags=()

    if [[ ! -d "${src_}" ]]; then
        log error "Source '${BLUE}${src_}${NC}' directory does not exist"
        return 1
    fi

    if [[ "$SYNC_" != "rsync" && $delete_flag -eq 1 ]]; then
        log error "Deletion of orphanes requires 'rsync'. Current: '$SYNC_'"
        return 1
    fi

    mkdir -p "${dest_}"

    if [[ "$SYNC_" == "rsync" ]]; then
        [[ $LOG_LEVEL -ge 2 ]] && cmd_flags+=( "--progress" )
        [[ $delete_flag -eq 1 ]] && cmd_flags+=( "--delete" )
        cmd_flags+=( "--archive" )
    elif [[ "$SYNC_" == "cp" ]]; then
        [[ $LOG_LEVEL -ge 2 ]] && cmd_flags+=( "--verbose" )
        cmd_flags+=( "--archive" "--no-target-directory"  )
    fi

    if $SYNC_ "${cmd_flags[@]}"  "${src_}/" "${dest_}/"; then
        log info "Copied '${GREEN}$(ColorPath "${src_}")${NC}' ${PURPLE}--->${NC} '${BLUE}$(ColorPath "${dest_}")${NC}'"
    else
        log error "Copy Failed: ${src_} --> ${dest_}"
    fi
}

function CloneRepo() {
    local DIR="$1"

    [[ -z "${USERNAME}" && -z "${REPO_NAME}" ]] && {
        log error "No github username or repo name is given"
        exit 1
    }

    if [[ -z "${DIR}" ]]; then
        log info "No directory given. Using your current directory to clone"
        DIR="$(realpath .)/${REPO_NAME}"
    else
        DIR="$(realpath "$1")/${REPO_NAME}"
    fi

    log debug "Getting dotfile repo from github"
    log info "Cloning your repository at: $DIR"
    git clone "https://github.com/${USERNAME}/${REPO_NAME}.git" "${DIR}" && \
        log info "Repository clone at '${BLUE}$(ColorPath "${DIR}")${NC}'"
}

function PushToRepo() {
    local force="$1"
    local satisfied=""
    local should_continue=""
    local should_commit=""
    local commit_template_file=""

    for file in ~/.git_commit_template_file ~/.gitmessage ~/.git_template; do
        [[ -s "${file}" ]] && commit_template_file="${file}"
    done

    [[ -z "${commit_template_file}" ]] && commit_template_file=<( printf "[tag] module: what changed\n\n" )

    if [[ -z "${USERNAME}" ]]; then
        log error "'USERNAME' is empty update your '$(ColorPath "${CONFIG_FILE}")'"
        return 1
    fi
    if [[ -z "${REPO_NAME}" ]]; then
        log error "'REPO_NAME' is empty update your '$(ColorPath "${CONFIG_FILE}")'"
        return 1
    fi

    cd "${GIT_DIR}"

    if ! git diff --quiet ; then
        log info "Launching git interactive git add"
        git add -p || {
            log error "Interactive staging failed"
            return 1
        }
    fi
    log info "Summary of staged changes"
    git diff --staged --stat

    printf "%s: " "Are you saisfied with changes? (y|n)"; read -r satisfied

    if [[ "${satisfied}" =~ ^(y|yes|Yes)$ ]]; then
        printf "%s: " "Commit? (y|n)"; read -r should_commit
        [[ "${should_commit}" =~ ^(y|yes|Yes)$ ]] || return 1
        if git commit --template="${commit_template_file}"; then
            log info "Successfully commited the changes"
        else
             if ! git diff --quiet --staged && git diff --quiet --staged; then
                 log error "Commit failed" && exit 1
             fi
        fi
    else
        log info "Commit aborted"
        printf "%s: " "Continue to commit?"; read -r should_continue
        [[ "${should_continue}" =~ ^(y|yes|Yes)$ ]] || exit 1
    fi
    log info "Pushing changes to git@github.com:${USERNAME}/${REPO_NAME}.git"
    git push "git@github.com:${USERNAME}/${REPO_NAME}.git" "$(git symbolic-ref --short HEAD)" "${force}" && \
        log info "Successfully pushed your changes to github repository"
}

function Cleanup() {
    log error "${RED}Interrupted, Clean up manually.${NC}" && exit 1
}

function Usage() {
    printf "%b\n" \
    "${HL}Sync and Backup dotfile${NC}" \
    "" \
    "Usage:" \
    "  BackUp [options]" \
    ""  \
    "Options:" \
    "  -h, --help            Show this help message and exit" \
    "  -v, --verbose         Set verbose output (LOG_LEVEL=1)" \
    "  -l=N, --log=N         Set log level (0=none, 1=error, 2=info, 3=debug)" \
    "  -d, --debug           Enable debug level logging (LOG_LEVEL=3)" \
    "  -e, --edit            Edit the config file ($(ColorPath "${CONFIG_FILE}"))" \
    "  -s, --show            Show the config file ($(ColorPath "${CONFIG_FILE}"))" \
    "  -g, --git-status      Show git status of your dotfile repo after backup" \
    "  -c DIR, --clone DIR   Clone your dotfile repo to specified DIR (local path)" \
    "  -m MSG, --msg MSG     Commit message for git push" \
    "  -p, --push            Push changes to your remote GitHub repository" \
    "  --force               Force git push with --force flag" \
    ""  \
    "Description:" \
    "  This script copies important config files and directories into a" \
    "  local git repository (${BLUE}$(ColorPath "${GIT_DIR}")${NC}) for backup and version control." \
    "  Optionally can clone your dotfiles repo from remote, push changes, and see git status." \
    "" \
    "Your Remote repo info:" \
    "  Username: ${BLUE}${USERNAME}${NC}" \
    "  Repository: ${BLUE}${REPO_NAME}${NC}"
}

trap Cleanup SIGINT SIGTERM

function main() {
    # An array to hold all the given flags
    local -a flagArr=("$@")

    # Temporary variable
    local -g MSG=""

    # 1 for git status 0 for no git status
    local git_status=0

    # Toggle push or pull
    local -i should_push=0 should_clone=0
    local -i show_help=0 show_config=0
    # Clone directory
    local clone_dir=""

    local force=""

    for ((i=0;i<${#flagArr[@]};i++)); do
        arg="${flagArr[$i]}"
        case "${arg}" in
            -v|-*verbose|-*progress|verbose)
                LOG_LEVEL=1
                log debug "Verbose is set"
                ;;
            -l=*|-*log*=*|log*=*)
                LOG_LEVEL=${arg#*=}
                if [[ -z ${LOG_LEVEL} || ${LOG_LEVEL} == -* ]] || [[ ! ${LOG_LEVEL} =~ ^[0-9]+$ ]]; then
                    LOG_LEVEL=1
                elif [[ $LOG_LEVEL -gt 3 ]]; then
                    log debug "LOG_LEVEL has no effect over integer ${LOG_LEVEL}"
                fi
                [[ $LOG_LEVEL -ge 3 ]] && log debug "Debugging enabled"
                ;;
            -l|-*log*|log*)
                LOG_LEVEL=${flagArr[$(( i + 1 ))]:-1}

                if [[ -z ${LOG_LEVEL} || ${LOG_LEVEL} == -* ]]; then
                    LOG_LEVEL=1
                elif [[ $LOG_LEVEL -gt 3 ]]; then
                    log debug "LOG_LEVEL has no effect over integer ${LOG_LEVEL}"
                fi
                [[ $LOG_LEVEL -ge 3 ]] && log debug "Debugging enabled"
                i=$(( i + 1 ))
                ;;
            -d-*debug|debug)
                LOG_LEVEL=2
                log debug "Debugging enabled"
                ;;
            -g|-*gs|-*git*stat*|git*stat*)
                git_status=1
                log debug "git_status is set"
                ;;
            -e|-*edit|edit)
                EditConfig "${CONFIG_FILE}"
                return 0
                ;;
            -s|-*show*|show*)
                show_config=1
                ;;
            -c|--clone*|clone*)
                clone_dir="${flagArr[$(( i + 1 ))]}"
                [[ -n "${clone_dir}" ]] && {
                    i=$(( i + 1 ))
                }
                should_clone=1
                ;;
            -c=*|-*clone*=*)
                clone_dir="${arg#*=}"
                should_clone=1
                ;;
            -m|-*msg)
                MSG="${flagArr[$(( i + 1 ))]}"
                [[ -n "${MSG}" ]] && {
                    i=$(( i + 1 ))
                }
                should_clone=1
                ;;
            -p|-*push|push)
                should_push=1
                LOG_LEVEL=2
                log debug "Backup will be pushed to github"
                ;;
            -*force)
                force="--force"
                log debug "Forcing push"
                ;;
            -h|-*help|help) show_help=1 ;;
            *)
                log error "Invalid flag: $arg"
                return 1
                ;;
        esac
    done

    mkdir -p "${CONFIG_FILE%/*}"

    SourceConfig "${CONFIG_FILE}"

    [[ $show_help -eq 1 ]] && { Usage; return 0; }
    [[ $show_config -eq 1 ]] && { ShowConfig; return 0; }

    ValidatePaths COPY_FILES || return 1
    ValidateDirPaths COPY_DIRS || return 1

    if [[ "${should_clone}" -eq 1 ]]; then
        CloneRepo "${clone_dir}"
        return 0
    fi

    if command -v rsync 1> /dev/null 2>&1; then
        SYNC_="rsync"
    elif command -v cp 1> /dev/null 2>&1; then
        SYNC_="cp"
    fi

    if [[ ! -d "${GIT_DIR}" ]]; then
        log info "$(ColorPath "${GIT_DIR}") doesn't exist"
        if mkdir -p "${GIT_DIR}"; then
            log info "Created $(ColorPath "${GIT_DIR}")"
        else
            log error "Cannot create '${BLUE}${GIT_DIR}${NC}'"
            return 1
        fi
    fi

    log debug "Using GIT_DIR=$(ColorPath "${GIT_DIR}")"
    log debug "Using git_status=$git_status"
    log debug "Using LOG_LEVEL=$LOG_LEVEL"
    log debug "Using SYNC_=$SYNC_"

    # Start copying all the files to the destination
    for pair in "${COPY_FILES[@]}"; do
        IFS=$'|' read -r src dest <<< "${pair}"
        CopyFiles "${src}" "${dest}"
    done

    # Start copying directory content with selective deletion
    for dir_spec in "${COPY_DIRS[@]}"; do
        IFS=$'|' read -r src dest delete_flag <<< "${dir_spec}"
        CopyDirs "${src}" "${dest}" "${delete_flag}"
    done

    if [[ ${git_status} -eq 1 ]]; then
        printf '\n\n'
        cd "${GIT_DIR}"
        if git status &> /dev/null; then
            git status
        else
            log error "Not a git repository"
        fi
    fi

    printf '\n' && log info "Dotfile directory: ${BLUE}$(ColorPath "${GIT_DIR}")${NC}\n"

    if [[ $should_push -eq 1 ]]; then
        PushToRepo "${force}" || return 1
    else
        return 0
    fi
}

main "$@"

